<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker概述和常用命令</title>
      <link href="/2022/08/07/docker%E6%A6%82%E8%BF%B0%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/08/07/docker%E6%A6%82%E8%BF%B0%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Docker概述"><a href="#1-Docker概述" class="headerlink" title="1. Docker概述"></a>1. Docker概述</h3><p>(1)基本介绍<br>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。官网：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p><p>(2)应用场景</p><p>Web 应用的自动化打包和发布。</p><p>自动化测试和持续集成、发布。</p><p>在服务型环境中部署和调整数据库或其他的后台应用。</p><p>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</p><p>(3)Docker 的优势</p><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p><p>1、快速，一致地交付您的应用程序。Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p><p>容器非常适合持续集成和持续交付（CI &#x2F; CD）工作流程，请考虑以下示例方案：</p><p>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。<br>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。<br>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。<br>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。<br>2、响应式部署和扩展<br>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p><p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p><p>3、在同一硬件上运行更多工作负载<br>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p><h3 id="2-Docker的基本组成"><a href="#2-Docker的基本组成" class="headerlink" title="2. Docker的基本组成"></a>2. Docker的基本组成</h3><p><img src="https://youyu-blog.oss-cn-beijing.aliyuncs.com/docker%E6%A6%82%E8%BF%B0%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20220807141049417.png" alt="image-20220807141049417"><img src="https://youyu-blog.oss-cn-beijing.aliyuncs.com/docker%E6%A6%82%E8%BF%B0%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20220807141115359.png" alt="image-20220807141115359"></p><h3 id="3-Docker的安装、启动和卸载"><a href="#3-Docker的安装、启动和卸载" class="headerlink" title="3. Docker的安装、启动和卸载"></a>3. Docker的安装、启动和卸载</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1.查看系统的内核：#系统内核版本为3.10.0[root@iZwz99sm8v95sckz8bd2c4Z ~]# uname -r3.10.0-957.21.3.el7.x86_64# 2.查看系统配置[root@iZwz99sm8v95sckz8bd2c4Z ~]# cat &#x2F;etc&#x2F;os-releaseNAME&#x3D;&quot;CentOS Linux&quot;VERSION&#x3D;&quot;7 (Core)&quot;ID&#x3D;&quot;centos&quot;ID_LIKE&#x3D;&quot;rhel fedora&quot;VERSION_ID&#x3D;&quot;7&quot;PRETTY_NAME&#x3D;&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR&#x3D;&quot;0;31&quot;CPE_NAME&#x3D;&quot;cpe:&#x2F;o:centos:centos:7&quot;HOME_URL&#x3D;&quot;https:&#x2F;&#x2F;www.centos.org&#x2F;&quot;BUG_REPORT_URL&#x3D;&quot;https:&#x2F;&#x2F;bugs.centos.org&#x2F;&quot;CENTOS_MANTISBT_PROJECT&#x3D;&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION&#x3D;&quot;7&quot;REDHAT_SUPPORT_PRODUCT&#x3D;&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION&#x3D;&quot;7&quot;# 3.卸载旧版本yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine# 4.下载需要的安装包yum install -y yum-utils# 5.设置镜像的仓库yum-config-manager \    --add-repo \    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo  #国外的地址        # 设置阿里云的Docker镜像仓库yum-config-manager \    --add-repo \    https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo  #国外的地址# 6.更新yum软件包索引yum makecache fast# 7.安装docker相关的配置# docker-ce 是社区版，docker-ee 企业版 yum install docker-ce docker-ce-cli containerd.io# 8.启动Dockersystemctl start docker# 查看当前版本号，是否启动成功docker version# 设置开机自启动systemctl enable docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><p><img src="https://youyu-blog.oss-cn-beijing.aliyuncs.com/docker%E6%A6%82%E8%BF%B0%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20220807141646294.png" alt="image-20220807141646294"></p><p>下载hello-world镜像进行测试</p><p><img src="https://youyu-blog.oss-cn-beijing.aliyuncs.com/docker%E6%A6%82%E8%BF%B0%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20220807141718528.png" alt="image-20220807141718528"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 9. 查看下载的hello world镜像[root@iZwz99sm8v95sckz8bd2c4Z lib]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED         SIZEhello-world   latest    bf756fb1ae65   11 months ago   13.3kB# 10. Docker的卸载# 1. 卸载依赖yum remove docker-ce docker-ce-cli containerd.io# 2. 删除资源  . &#x2F;var&#x2F;lib&#x2F;docker是docker的默认工作路径rm -rf &#x2F;var&#x2F;lib&#x2F;docker#  11.配置阿里云镜像加速（1）进入阿里云官网，搜索容器镜像服务 (2) 执行类似下面的四条命令 sudo mkdir -p &#x2F;etc&#x2F;dockersudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123;  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;axvfsf7e.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-Docker常用命令"><a href="#4-Docker常用命令" class="headerlink" title="4. Docker常用命令"></a>4. Docker常用命令</h3><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><blockquote><p>docker version          #查看docker的版本信息<br>docker info             #查看docker的系统信息,包括镜像和容器的数量<br>docker 命令 –help       #帮助命令(可查看可选的参数)<br>docker COMMAND –help</p></blockquote><h4 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1.docker images 查看本地主机的所有镜像[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker imagesREPOSITORY    TAG       IMAGE ID       CREATED         SIZEhello-world   latest    bf756fb1ae65   11 months ago   13.3kB#解释:1.REPOSITORY  镜像的仓库源2.TAG  镜像的标签3.IMAGE ID 镜像的id4.CREATED 镜像的创建时间5.SIZE 镜像的大小# 可选参数-a&#x2F;--all 列出所有镜像-q&#x2F;--quiet 只显示镜像的id# 2.docker search 搜索镜像[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker search mysql# 3.docker pull 镜像名[:tag] 下载镜像[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker pull mysql# 4.指定版本下载[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker pull mysql:5.7# 5.docker rmi 删除镜像    #1.删除指定的镜像id    [root@iZwz99sm8v95sckz8bd2c4Z ~]# docker rmi -f  镜像id    #2.删除多个镜像id    [root@iZwz99sm8v95sckz8bd2c4Z ~]# docker rmi -f  镜像id 镜像id 镜像id    #3.删除全部的镜像id    [root@iZwz99sm8v95sckz8bd2c4Z ~]# docker rmi -f  $(docker images -aq)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 如拉取一个centos镜像docker pull centos# 1.运行容器的命令docker run [可选参数] image# 2.运行并进入容器centos[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker run -it centos &#x2F;bin&#x2F;bash[root@bd1b8900c547 &#x2F;]# ls      bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var# 3.退出容器命令[root@bd1b8900c547 &#x2F;]# exitexit# 4.列出运行过的容器命令[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker ps# 5.删除容器命令docker rm 容器id                 #删除指定的容器,不能删除正在运行的容器,强制删除使用 rm -fdocker rm -f $(docker ps -aq)   #删除所有的容器docker ps -a -q|xargs docker rm #删除所有的容器# 6.启动和停止容器命令docker start 容器id          #启动容器docker restart 容器id        #重启容器docker stop 容器id           #停止当前运行的容器docker kill 容器id           #强制停止当前容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1.日志的查看[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker logs --help# 2. 查看容器中进程信息[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker top 容器id# 3.查看容器的元数据[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker inspect 容器id# 4.进入当前正在运行的容器# 因为通常我们的容器都是使用后台方式来运行的，有时需要进入容器修改配置方式一： [root@iZwz99sm8v95sckz8bd2c4Z ~]# docker exec -it 容器id &#x2F;bin&#x2F;bash方式二： [root@iZwz99sm8v95sckz8bd2c4Z ~]# docker attach 容器id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-提交镜像"><a href="#5-提交镜像" class="headerlink" title="5. 提交镜像"></a>5. 提交镜像</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 使用docker commit 命令提交容器成为一个新的版本docker commit -m&#x3D;“提交的描述信息”  -a&#x3D;&quot;作者&quot; 容器id 目标镜像名:[TAG] eg:# 由于默认的Tomcat镜像的webapps文件夹中没有任何内容，需要从webapps.dist中拷贝文件到webapps文件夹。下面自行制作镜像：就是从webapps.dist中拷贝文件到webapps文件夹下，并提交该镜像作为一个新的镜像。使得该镜像默认的webapps文件夹下就有文件。具体命令如下：  #1.复制文件夹[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker run -it tomcat &#x2F;bin&#x2F;bashroot@2a3bf3eaa2e4:&#x2F;usr&#x2F;local&#x2F;tomcat# cd webappsroot@2a3bf3eaa2e4:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps# lsroot@2a3bf3eaa2e4:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps# cd ..&#x2F;root@2a3bf3eaa2e4:&#x2F;usr&#x2F;local&#x2F;tomcat# cp -r webapps.dist&#x2F;* webappsroot@2a3bf3eaa2e4:&#x2F;usr&#x2F;local&#x2F;tomcat# cd webappsroot@2a3bf3eaa2e4:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps# lsROOT  docs  examples  host-manager  manager[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker psCONTAINER ID   IMAGE                 COMMAND        CREATED         STATUS         PORTS                    NAMES2a3bf3eaa2e4   tomcat                &quot;&#x2F;bin&#x2F;bash&quot;    4 minutes ago   Up 4 minutes   8080&#x2F;tcp                 competent_torvalds7789d4505a00   portainer&#x2F;portainer   &quot;&#x2F;portainer&quot;   24 hours ago    Up 24 hours    0.0.0.0:8088-&gt;9000&#x2F;tcp   quirky_sinoussi[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker exec -it 2a3bf3eaa2e4 &#x2F;bin&#x2F;bashroot@2a3bf3eaa2e4:&#x2F;usr&#x2F;local&#x2F;tomcat# cd webappsroot@2a3bf3eaa2e4:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps# lsROOT  docs  examples  host-manager  managerroot@2a3bf3eaa2e4:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps# cd ..&#x2F;root@2a3bf3eaa2e4:&#x2F;usr&#x2F;local&#x2F;tomcat# read escape sequence[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker psCONTAINER ID   IMAGE                 COMMAND        CREATED         STATUS         PORTS                    NAMES2a3bf3eaa2e4   tomcat                &quot;&#x2F;bin&#x2F;bash&quot;    8 minutes ago   Up 8 minutes   8080&#x2F;tcp                 competent_torvalds7789d4505a00   portainer&#x2F;portainer   &quot;&#x2F;portainer&quot;   24 hours ago    Up 24 hours    0.0.0.0:8088-&gt;9000&#x2F;tcp   quirky_sinoussi#2.提交镜像作为一个新的镜像[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker commit -m&#x3D;&quot;add webapps&quot; -a&#x3D;&quot;Ethan&quot; 2a3bf3eaa2e4 mytomcat:1.0sha256:f189aac861de51087af5bc88a5f1de02d9574e7ee2d163c647dd7503a2d3982b[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker imagesREPOSITORY            TAG       IMAGE ID       CREATED         SIZEmytomcat              1.0       f189aac861de   7 seconds ago   653MBmysql                 5.7       f07dfa83b528   6 days ago      448MBtomcat                latest    feba8d001e3f   10 days ago     649MBnginx                 latest    ae2feff98a0c   12 days ago     133MBcentos                latest    300e315adb2f   2 weeks ago     209MBportainer&#x2F;portainer   latest    62771b0b9b09   5 months ago    79.1MBelasticsearch         7.6.2     f29a1ee41030   9 months ago    791MB#3.运行容器[root@iZwz99sm8v95sckz8bd2c4Z ~]# docker run -it mytomcat:1.0 &#x2F;bin&#x2F;bashroot@1645774d4605:&#x2F;usr&#x2F;local&#x2F;tomcat# cd webappsroot@1645774d4605:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps# lsROOT  docs  examples  host-manager  managerwz99sm8v95sckz8bd2c4Z ~]# docker imagesREPOSITORY            TAG       IMAGE ID       CREATED         SIZEmytomcat              1.0       f189aac861de   7 seconds ago   653MBmysql                 5.7       f07dfa83b528   6 days ago      448MBtomcat                latest    feba8d001e3f   10 days ago     649MBnginx                 latest    ae2feff98a0c   12 days ago     133MBcentos                latest    300e315adb2f   2 weeks ago     209MBportainer&#x2F;portainer   latest    62771b0b9b09   5 months ago    79.1MBelasticsearch         7.6.2     f29a1ee41030   9 months ago    791MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结：掌握了以上基本的Docker命令，才是Docker入门的基础哦！！！"><a href="#总结：掌握了以上基本的Docker命令，才是Docker入门的基础哦！！！" class="headerlink" title="总结：掌握了以上基本的Docker命令，才是Docker入门的基础哦！！！"></a>总结：掌握了以上基本的Docker命令，才是Docker入门的基础哦！！！</h3>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java算法常用Api</title>
      <link href="/2022/07/26/Java%E7%AE%97%E6%B3%95%E5%B8%B8%E7%94%A8Api/"/>
      <url>/2022/07/26/Java%E7%AE%97%E6%B3%95%E5%B8%B8%E7%94%A8Api/</url>
      
        <content type="html"><![CDATA[<ol><li><p>int 型 转 String 型</p><blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">String.valueOf(int x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote></li><li><p>字符串反转工具StringBuffer（安全），StringBuild（不安全）</p><blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">StringBuffer start &#x3D; new StringBuffer(String str);StringBuffer end&#x3D; start.reverse();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote></li><li><p>数组去长度，和字符串取长度</p></li></ol><blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;数组String[] strs &#x3D; &#123;1,2,3&#125;;strs.length    &#x2F;&#x2F; 字符串String str &#x3D; &quot;123456&quot;;str.length()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信支付</title>
      <link href="/2022/07/21/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/"/>
      <url>/2022/07/21/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/</url>
      
        <content type="html"><![CDATA[<h2 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h2><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h3><ol><li>你需要注册一个<a href="https://open.weixin.qq.com/">开发者资质的认证</a>(只支持企业类型，收费)</li><li>关联的公众号appId</li><li>商户号</li><li>商户key</li><li>回调地址</li></ol><h3 id="2-引入微信支付相关依赖"><a href="#2-引入微信支付相关依赖" class="headerlink" title="2.引入微信支付相关依赖"></a>2.引入微信支付相关依赖</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;dependency&gt;    &lt;groupId&gt;com.github.wxpay&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;wxpay-sdk&lt;&#x2F;artifactId&gt;    &lt;version&gt;0.0.3&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-生成支付微信二维码"><a href="#3-生成支付微信二维码" class="headerlink" title="3.生成支付微信二维码"></a>3.生成支付微信二维码</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">#支付#关联的公众号appidweixin.pay.appid&#x3D;微信id#商户号weixin.pay.partner&#x3D;商户号#商户keyweixin.pay.partnerkey&#x3D;商户key#回调地址weixin.pay.notifyurl&#x3D;回调地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;        2、使用map设置二维码需要的参数            Map map &#x3D; new HashMap&lt;&gt;();            map.put(&quot;appid&quot;, appId);            map.put(&quot;mch_id&quot;, partner);            map.put(&quot;nonce_str&quot;, WXPayUtil.generateNonceStr());            map.put(&quot;body&quot;, order.getCourseTitle());            map.put(&quot;out_trade_no&quot;, orderId);            map.put(&quot;total_fee&quot;, order.getTotalFee().multiply(new BigDecimal(&quot;100&quot;)).longValue() + &quot;&quot;);   &#x2F;&#x2F;元角分转换成long            map.put(&quot;spbill_create_ip&quot;, &quot;127.0.0.1&quot;);   &#x2F;&#x2F;baidu.com            map.put(&quot;notify_url&quot;, notifyurl); &#x2F;&#x2F;回调地址            map.put(&quot;trade_type&quot;, &quot;NATIVE&quot;);&#x2F;&#x2F;支付类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>发送httpClient请求，传递参数xml格式，微信提供的固定地址</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">            HttpClient client &#x3D; new HttpClient(&quot;https:&#x2F;&#x2F;api.mch.weixin.qq.com&#x2F;pay&#x2F;unifiedorder&quot;);  &#x2F;&#x2F;这个地址是固定的&#x2F;&#x2F;向请求中设置参数            client.setXmlParam(WXPayUtil.generateSignedXml(map,partnerkey));            client.setHttps(true);&#x2F;&#x2F;https不支持，要写上这个才支持&#x2F;&#x2F;            执行请求发送            client.post();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>请求发送后得到一个结果（xml格式），我们需转换为map格式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;        4、得到发送请求返回结果&#x2F;&#x2F;            返回的内容是xml格式返回的，我们可以把xml格式转为map集合  这里不能用GsonString content &#x3D; client.getContent();            Map&lt;String,String&gt; resultMap &#x3D; WXPayUtil.xmlToMap(content);&#x2F;&#x2F;            这里返回的resultMap只有二维码地址，而我们还需要其他信息，所以封装            Map mapAdd &#x3D; new HashMap&lt;&gt;();            mapAdd.put(&quot;out_trade_no&quot;, orderId);            mapAdd.put(&quot;course_id&quot;, order.getCourseId());            mapAdd.put(&quot;total_fee&quot;, order.getTotalFee());            mapAdd.put(&quot;result_code&quot;, resultMap.get(&quot;result_code&quot;));    &#x2F;&#x2F;返回二维码的状态码            mapAdd.put(&quot;code_url&quot;, resultMap.get(&quot;code_url&quot;));  &#x2F;&#x2F;返回二维码的地址            return mapAdd;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="4-生成微信支付二维码成功"><a href="#4-生成微信支付二维码成功" class="headerlink" title="4.生成微信支付二维码成功"></a>4.生成微信支付二维码成功</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 微信支付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信登录</title>
      <link href="/2022/07/21/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"/>
      <url>/2022/07/21/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="微信登录"><a href="#微信登录" class="headerlink" title="微信登录"></a>微信登录</h2><h3 id="1-准备工作："><a href="#1-准备工作：" class="headerlink" title="1.准备工作："></a>1.准备工作：</h3><ol><li>你需要注册一个<a href="https://open.weixin.qq.com/">开发者资质的认证</a>(只支持企业类型，收费)</li><li>注册成功后，会得到一个微信id和微信密钥</li><li>扫完微信二维码后需要得到一个域名的地址</li></ol><p>所以我们使用微信登陆需要三个东西（微信id，微信密钥，域名地址）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"># 微信登录配置# 微信开放平台 appidwx.open.app_id&#x3D;微信id# 微信开放平台 appsecretwx.open.app_secret&#x3D;微信密钥# 微信开放平台 重定向urlwx.open.redirect_url&#x3D;域名地址&#x2F;&#x2F;特别注明：&#x3D;两边不能出现空格，否则将会解析错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-生成微信二维码"><a href="#2-生成微信二维码" class="headerlink" title="2.生成微信二维码"></a>2.生成微信二维码</h3><ol><li>我们需要去请求一个固定的地址，并且传一些参数</li></ol><p>通过在PC端打开以下链接：<br><a href="https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect">https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</a></p><p><strong>参数说明</strong></p><table><thead><tr><th align="left">参数</th><th align="left">是否必须</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">appid</td><td align="left">是</td><td align="left">应用唯一标识</td></tr><tr><td align="left">redirect_uri</td><td align="left">是</td><td align="left">请使用urlEncode对链接进行处理（需要做个编码）</td></tr><tr><td align="left">response_type</td><td align="left">是</td><td align="left">填code</td></tr><tr><td align="left">scope</td><td align="left">是</td><td align="left">应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即</td></tr><tr><td align="left">state</td><td align="left">否</td><td align="left">用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验</td></tr></tbody></table><ol start="2"><li><p>参数填充</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;       %s相当于?，表示占位符        String baseUrl &#x3D; &quot;https:&#x2F;&#x2F;open.weixin.qq.com&#x2F;connect&#x2F;qrconnect&quot; +        &quot;?appid&#x3D;%s&quot; +        &quot;&amp;redirect_uri&#x3D;%s&quot; +        &quot;&amp;response_type&#x3D;code&quot; +        &quot;&amp;scope&#x3D;snsapi_login&quot; +        &quot;&amp;state&#x3D;%s&quot; +        &quot;#wechat_redirect&quot;;&#x2F;&#x2F;        需要对url进行编码，将特殊符合进行处理        String redirectUrl &#x3D; URLEncoder.encode(域名地址,&quot;utf-8&quot;);        String url &#x3D; String.format(                baseUrl,                wxOpenAppId,                redirectUrl,                &quot;秋有鱼&quot;        );&#x2F;&#x2F;最终这个固定地址里面就包含了我们所需要的参数值        return &quot;redirect:&quot;+url;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>这样去访问到的url就能得到一个微信二维码</p><h3 id="3-微信扫描二维码"><a href="#3-微信扫描二维码" class="headerlink" title="3. 微信扫描二维码"></a>3. 微信扫描二维码</h3><ol><li><p>扫描二维码后，它会去调用我们的域名地址（即地址栏发生变化）</p><p><strong>因为我们是个人项目，以后公司项目就不用下面所说的步骤那么麻烦</strong></p></li><li><p>把本地服务端口号改成，地址栏显示的端口号</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">server.port&#x3D;8160<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>回调接口的地址和域名跳转的地址写成一样</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequestMapping(&quot;&#x2F;api&#x2F;ucenter&#x2F;wx&quot;)&#x2F;&#x2F;    这种规则只是为了测试使用，在实际开发中，把程序直接部署到域名服务器上即可&#x2F;&#x2F;    http:&#x2F;&#x2F;localhost:8160&#x2F;api&#x2F;ucenter&#x2F;wx&#x2F;callback?code&#x3D;021P2o000LHZ8O1Wr7300m9CmP3P2o09&amp;state&#x3D;秋有鱼&#x2F;&#x2F;    这个路径必须是callback&#x2F;&#x2F;    获取扫描人信息&#x2F;&#x2F;    扫完二维码后，默认调用callback方法    @GetMapping(&quot;&#x2F;callback&quot;) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>写一个方法接收这两个参数，拿着获取到的code值，再去请求微信提供的固定地址</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String baseAccessTokenUrl &#x3D; &quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;oauth2&#x2F;access_token&quot; +&quot;?appid&#x3D;%s&quot; +&quot;&amp;secret&#x3D;%s&quot; +&quot;&amp;code&#x3D;%s&quot; +&quot;&amp;grant_type&#x3D;authorization_code&quot;;String accessTokenUrl &#x3D; String.format(        baseAccessTokenUrl,        wxOpenAppId,        wxOpenAppSecret,        code);&#x2F;&#x2F;access_token：访问凭证&#x2F;&#x2F;openid：每个微信的一个唯一标识   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>accessToken，openid转换</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;        请求这个拼接好的地址，得到access_token(访问凭证)，openid&#x2F;&#x2F;        我们并不需要请求这个页面，所以要用到httpclient，得到返回结果&#x2F;&#x2F;        httpclient，不用浏览器，能模拟出浏览器的请求和响应        String accessTokenInfo &#x3D; HttpClientUtils.get(accessTokenUrl);&#x2F;&#x2F;        要从accessTokenInfo中获取access_token(访问凭证)，openid&#x2F;&#x2F;        因为accessTokenInfo是json格式，要获取其中变量和值，转为map格式&#x2F;&#x2F;        使用json转换工具Gson        Gson gson &#x3D; new Gson();        HashMap map &#x3D; gson.fromJson(accessTokenInfo, HashMap.class);        String access_token &#x3D; (String) map.get(&quot;access_token&quot;);        String openid &#x3D; (String) map.get(&quot;openid&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>拿着上一步获得的access_token和openid，再去请求微信提供的固定地址</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;        3.拿着得到的access_token，openid，再去访问微信提供的固定地址，获取到扫面人的信息        String baseUserInfoUrl &#x3D; &quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;sns&#x2F;userinfo&quot; +        &quot;?access_token&#x3D;%s&quot; +        &quot;&amp;openid&#x3D;%s&quot;;        String userInfoUrl &#x3D; String.format(                baseUserInfoUrl,                access_token,                openid        );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最终可以得到扫描微信二维码人的信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">        String userInfo &#x3D; HttpClientUtils.get(userInfoUrl);&#x2F;&#x2F;        System.out.println(userInfo);        HashMap map1 &#x3D; gson.fromJson(userInfo, HashMap.class);        String openid1 &#x3D; (String) map1.get(&quot;openid&quot;);        String nickname &#x3D; (String) map1.get(&quot;nickname&quot;);        String headimgurl &#x3D; (String) map1.get(&quot;headimgurl&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="4-最后得到微信扫描人的信息"><a href="#4-最后得到微信扫描人的信息" class="headerlink" title="4.最后得到微信扫描人的信息"></a>4.最后得到微信扫描人的信息</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 微信登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在线教育项目总结</title>
      <link href="/2022/07/21/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/21/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1、项目描述"><a href="#1、项目描述" class="headerlink" title="1、项目描述"></a>1、项目描述</h3><p>（1）</p><p>在线教育系统，分为前台网站系统和后台运营平台，B2C模式。</p><p>前台用户系统包括课程、讲师、问答、文章几大大部分，使用了微服务技术架构，前后端分离开发。</p><p>后端的主要技术架构是：SpringBoot + SpringCloud + MyBatis-Plus + HttpClient + MySQL + Maven+EasyExcel+ nginx</p><p>前端的架构是：Node.js + Vue.js +element-ui+NUXT+ECharts</p><p>其他涉及到的中间件包括Redis、阿里云OSS、阿里云视频点播</p><p>业务中使用了ECharts做图表展示，使用EasyExcel完成分类批量添加、注册分布式单点登录使用了JWT</p><p>（2）</p><p>项目前后端分离开发，后端采用SpringCloud微服务架构，持久层用的是MyBatis-Plus，微服务分库设计，使用Swagger生成接口文档</p><p>接入了阿里云视频点播、阿里云OSS。</p><p>系统分为前台用户系统和后台管理系统两部分。</p><p>前台用户系统包括：首页、课程、名师、问答、文章。</p><p>后台管理系统包括：讲师管理、课程分类管理、课程管理、统计分析、Banner管理、订单管理、权限管理等功能。</p><p>在线教育计费案例：</p><p>小A是一名杭州的创业者，带领团队研发了一个在线教育平台。他希望把视频托管在阿里云上，存量视频大约1000个，占用存储空间近1T，每月预计新增视频100个，并新增存储约100G，课程视频的时长集中在20-40分钟，并且按照不同课程进行分类管理。为了保障各端的观看效果，计划为用户提供“标清480P”和“高清720P”两种清晰度。目前已有用户400人左右，每日平均视频观看次数1000次，在移动端和PC端观看次数比例大致为3:1。</p><h3 id="2、这是一个项目还是一个产品"><a href="#2、这是一个项目还是一个产品" class="headerlink" title="2、这是一个项目还是一个产品"></a>2、这是一个项目还是一个产品</h3><p>这是一个产品</p><p>1.0版本是单体应用：SSM</p><p>2.0版本加入了SpringCloud，将一些关键业务和访问量比较大的部分分离了出去</p><p>目前独立出来的服务有教学服务、视频点播服务、用户服务、统计分析服务、网关服务</p><h3 id="3、测试要求"><a href="#3、测试要求" class="headerlink" title="3、测试要求"></a>3、测试要求</h3><p>首页和视频详情页qps单机qps要求 2000+</p><p>经常用每秒查询率来衡量域名系统服务器的机器的性能，其即为QPS</p><p>QPS &#x3D; 并发量 &#x2F; 平均响应时间</p><h3 id="4、企业中的项目（产品）开发流程"><a href="#4、企业中的项目（产品）开发流程" class="headerlink" title="4、企业中的项目（产品）开发流程"></a>4、企业中的项目（产品）开发流程</h3><p>一个中大型项目的开发流程</p><p>1、需求调研（产品经理）</p><p>2、需求评审（产品&#x2F;设计&#x2F;前端&#x2F;后端&#x2F;测试&#x2F;运营）</p><p>3、立项（项目经理、品管）</p><p>4、UI设计</p><p>5、开发</p><ul><li>架构、数据库设计、API文档、MOCK数据、开发、单元测试</li><li>前端</li><li>后端</li></ul><p>6、前端后端联调</p><p>7、项目提测：黑盒白盒、压力测试（qps）  loadrunner</p><p>8、bug修改</p><p>9、回归测试</p><p>10、运维和部署上线</p><p>11、灰度发布</p><p>12、全量发布</p><p>13、维护和运营</p><p>5、系统中都有那些角色？数据库是怎么设计的？</p><p>前台：会员（学员）</p><p>后台：系统管理员、运营人员</p><p>后台分库，每个微服务一个独立的数据库，使用了分布式id生成器</p><h3 id="6、视频点播是怎么实现的（流媒体你们是怎么实现的）"><a href="#6、视频点播是怎么实现的（流媒体你们是怎么实现的）" class="headerlink" title="6、视频点播是怎么实现的（流媒体你们是怎么实现的）"></a>6、视频点播是怎么实现的（流媒体你们是怎么实现的）</h3><p>我们直接接入了阿里云的云视频点播。云平台上的功能包括视频上传、转码、加密、智能审核、监控统计等。</p><p>还包括视频播放功能，阿里云还提供了一个视频播放器。</p><h3 id="7、前后端联调经常遇到的问题："><a href="#7、前后端联调经常遇到的问题：" class="headerlink" title="7、前后端联调经常遇到的问题："></a>7、前后端联调经常遇到的问题：</h3><p>   1、请求方式post、get</p><p>   2、json、x-wwww-form-urlencoded混乱的错误</p><p>   3、后台必要的参数，前端省略了</p><p>   4、数据类型不匹配</p><p>   5、空指针异常</p><p>   6、分布式系统中分布式id生成器生成的id 长度过大（19个字符长度的整数），js无法解析（js智能解析16个长度：2的53次幂）</p><p>​     id策略改成 ID_WORKER_STR</p><h3 id="8、前后端分离项目中的跨域问题是如何解决的"><a href="#8、前后端分离项目中的跨域问题是如何解决的" class="headerlink" title="8、前后端分离项目中的跨域问题是如何解决的"></a>8、前后端分离项目中的跨域问题是如何解决的</h3><p>后端服务器配置：我们的项目中是通过Spring注解解决跨域的 @CrossOrigin</p><p>也可以使用nginx反向代理、httpClient、网关</p><h3 id="9、说说你做了哪个部分、遇到了什么问题、怎么解决的"><a href="#9、说说你做了哪个部分、遇到了什么问题、怎么解决的" class="headerlink" title="9、说说你做了哪个部分、遇到了什么问题、怎么解决的"></a>9、说说你做了哪个部分、遇到了什么问题、怎么解决的</h3><p>问题1：</p><p>分布式id生成器在前端无法处理，总是在后三位进行四舍五入。</p><p>分布式id生成器生成的id是19个字符的长度，前端javascript脚本对整数的处理能力只有2的53次方，也就是最多只能处理16个字符</p><p>解决的方案是把id在程序中设置成了字符串的性质</p><p>问题2：</p><p>项目迁移到Spring-Cloud的时候，经过网关时，前端传递的cookie后端一只获取不了，看了cloud中zuul的源码，发现向下游传递数据的时候，zull默认过滤了敏感信息，将cookie过滤掉了</p><p>解决的方案是在配置文件中将请求头的过滤清除掉，使cookie可以向下游传递</p><p>问题3…….</p><h3 id="10、分布式系统的id生成策略"><a href="#10、分布式系统的id生成策略" class="headerlink" title="10、分布式系统的id生成策略"></a>10、分布式系统的id生成策略</h3><p><a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">主键生成策略</a></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="11、项目组有多少人，人员如何组成？"><a href="#11、项目组有多少人，人员如何组成？" class="headerlink" title="11、项目组有多少人，人员如何组成？"></a>11、项目组有多少人，人员如何组成？</h3><h3 id="12、分布式系统的CAP原理"><a href="#12、分布式系统的CAP原理" class="headerlink" title="12、分布式系统的CAP原理"></a>12、分布式系统的CAP原理</h3><p><strong>CAP定理：</strong></p><p>指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得。</p><p> 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（所有节点在同一时间的数据完全一致，越多节点，数据同步越耗时）</p><p>可用性（A）：负载过大后，集群整体是否还能响应客户端的读写请求。（服务一直可用，而且是正常响应时间）</p><p>分区容错性（P）：分区容错性，就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好）</p><p><strong>CA 满足的情况下，P不能满足的原因：</strong></p><p>数据同步(C)需要时间，也要正常的时间内响应(A)，那么机器数量就要少，所以P就不满足</p><p><strong>CP 满足的情况下，A不能满足的原因：</strong></p><p>数据同步(C)需要时间, 机器数量也多(P)，但是同步数据需要时间，所以不能再正常时间内响应，所以A就不满足</p><p><strong>AP 满足的情况下，C不能满足的原因：</strong></p><p>机器数量也多(P)，正常的时间内响应(A)，那么数据就不能及时同步到其他节点，所以C不满足</p><p><strong>注册中心选择的原则：</strong></p><p>Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或者半数以上节点不可用，则无法提供服务，因此可用性没法满足</p><p>Eureka：AP原则，无主从节点，一个节点挂了，自动切换其他节点可以使用，去中心化</p><p><strong>结论：</strong></p><p>分布式系统中P,肯定要满足，所以我们只能在一致性和可用性之间进行权衡</p><p>如果要求一致性，则选择zookeeper，如金融行业</p><p>如果要求可用性，则Eureka，如教育、电商系统</p><p>没有最好的选择，最好的选择是根据业务场景来进行架构设计</p><h3 id="13、前端渲染和后端渲染有什么区别"><a href="#13、前端渲染和后端渲染有什么区别" class="headerlink" title="13、前端渲染和后端渲染有什么区别"></a>13、<strong>前端渲染和后端渲染有什么区别</strong></h3><p>前端渲染是返回json给前端，通过javascript将数据绑定到页面上</p><p>后端渲染是在服务器端将页面生成直接发送给服务器，有利于SEO的优化</p><h3 id="14、能画一下系统架构图吗"><a href="#14、能画一下系统架构图吗" class="headerlink" title="14、能画一下系统架构图吗"></a><strong>14、能画一下系统架构图吗</strong></h3><p><img src="https://edu-youyu.oss-cn-beijing.aliyuncs.com/%E5%9C%A8%E7%BA%BF%E6%95%99%E8%82%B2%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/af43e6f7168dd36951b3bf819d7a18f.png" alt="img"></p><h3 id="15、值得学习的技术"><a href="#15、值得学习的技术" class="headerlink" title="15、值得学习的技术"></a>15、值得学习的技术</h3><h4 id="oss"><a href="#oss" class="headerlink" title="oss"></a>oss</h4><ul><li>上传（文件&#x2F;头像）若没有用到数据库，则需要取消数据库的配置</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;MultipartFilepublic R uploadOssFile(MultipartFile file)    &#x2F;&#x2F; 利用oss存储图片文件&#x2F;&#x2F;        创建OSSClient实例        OSS ossClient &#x3D; new OSSClientBuilder().build(endPoint, keyId, keySecret);&#x2F;&#x2F;        上传文件流        try &#123;            InputStream inputStream &#x3D; file.getInputStream();&#x2F;&#x2F;            获取文件名称            String uuid &#x3D; UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);            String filename &#x3D; uuid + file.getOriginalFilename();&#x2F;&#x2F;            调用oss的方法实现上传&#x2F;&#x2F;            1.Bucket名称&#x2F;&#x2F;            2.上传到oss文件路径和文件名称 aa&#x2F;bb&#x2F;1.jpg     1.jpg（一般写文件名称）&#x2F;&#x2F;            3.上传文件的输入流&#x2F;&#x2F;            第二个参数可以按aa&#x2F;bb&#x2F;1.jpg&#x2F;&#x2F;            把文件按照日期进行分类       2019&#x2F;11&#x2F;12&#x2F;1.jpg            String date &#x3D; new DateTime().toString(&quot;yyyy&#x2F;MM&#x2F;dd&quot;);&#x2F;&#x2F;            最终拼接            filename &#x3D; date + &quot;&#x2F;&quot; + filename;            ossClient.putObject(bucketName,filename,inputStream);&#x2F;&#x2F;            关闭oss            ossClient.shutdown();&#x2F;&#x2F;            把上传之后的文件路径返回&#x2F;&#x2F;            需要把上传到阿里云oss路径手动拼接出来&#x2F;&#x2F;            https:&#x2F;&#x2F;edu-youyu.oss-cn-beijing.aliyuncs.com&#x2F;a.jpg            String url &#x3D; &quot;https:&#x2F;&#x2F;&quot;+bucketName+&quot;.&quot;+endPoint+&quot;&#x2F;&quot;+filename;            return url;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二层（章节包含小节情况）"><a href="#二层（章节包含小节情况）" class="headerlink" title="二层（章节包含小节情况）"></a>二层（章节包含小节情况）</h4><ul><li><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//        1、根据课程id查询课程所有章节</span>        <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EduChapter</span><span class="token punctuation">></span></span> wrapperChapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        wrapperChapter<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"course_id"</span><span class="token punctuation">,</span>courseId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EduChapter</span><span class="token punctuation">></span></span> eduChapterList <span class="token operator">=</span> baseMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>wrapperChapter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        2、根据课程id查询章节的所有小节</span>        <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EduVideo</span><span class="token punctuation">></span></span> wrapperVideo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        wrapperVideo<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"course_id"</span><span class="token punctuation">,</span>courseId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">EduVideo</span><span class="token punctuation">></span></span> listVideoList<span class="token operator">=</span> eduVideoService<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span>wrapperVideo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        创建list集合，用于最终封装的数据</span>        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ChapterVo</span><span class="token punctuation">></span></span> finalist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        3、遍历查询章节list集合进行封装</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> eduChapterList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//            得到每个章节</span>            <span class="token class-name">EduChapter</span> eduChapter <span class="token operator">=</span> eduChapterList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">ChapterVo</span> chapterVo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChapterVo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>eduChapter<span class="token punctuation">,</span>chapterVo<span class="token punctuation">)</span><span class="token punctuation">;</span>            finalist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>chapterVo<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">VideoVo</span><span class="token punctuation">></span></span> videoList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        4、便利查询小节list集合进行封装</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> listVideoList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">EduVideo</span> eduVideo <span class="token operator">=</span> listVideoList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>chapterVo<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>eduVideo<span class="token punctuation">.</span><span class="token function">getChapterId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token class-name">VideoVo</span> videoVo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VideoVo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">BeanUtils</span><span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>eduVideo<span class="token punctuation">,</span>videoVo<span class="token punctuation">)</span><span class="token punctuation">;</span>                    videoList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>videoVo<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>            chapterVo<span class="token punctuation">.</span><span class="token function">setChildren</span><span class="token punctuation">(</span>videoList<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> finalist<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><blockquote><p><strong>BeanUtils.copyProperties</strong>：将得到的实体类的get值，set到另一个实体类中去</p></blockquote><blockquote><p>**StringUtils.isEmpty(videoSourceId)**：判断是否为空</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 全栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组常用方法</title>
      <link href="/2022/07/20/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2022/07/20/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="数组常用的方法"><a href="#数组常用的方法" class="headerlink" title="数组常用的方法"></a>数组常用的方法</h2><p> es6新增的方法，与for循环一样，但是没有内置的index。</p><h3 id="1-for-of循环"><a href="#1-for-of循环" class="headerlink" title="1. for of循环"></a>1. for of循环</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//do something</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>item <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-forEach"><a href="#2-forEach" class="headerlink" title="2. forEach"></a>2. forEach</h3><p> Array.prototype上内置的，遍历出item和index,不会改变原数组，没有返回值。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">//do something</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-map"><a href="#3-map" class="headerlink" title="3. map"></a>3. map</h3><p> 获得原数组的映射，遍历出item和index,不会改变原数组，返回新数组。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> newList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=></span> item <span class="token operator">*</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[0,2,6]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-filter"><a href="#4-filter" class="headerlink" title="4. filter"></a>4. filter</h3><p> 执行迭代函数的返回值如果为真值，则会将这个成员放进新数组，若为假，则不放入，不会改变原数组，返回新数组。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> newList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=></span> item <span class="token operator">*</span> index <span class="token operator">>=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[3]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="5-find和findIndex"><a href="#5-find和findIndex" class="headerlink" title="5. find和findIndex"></a>5. find和findIndex</h3><p> find()返回值的结果是第一个执行迭代函数的返回值为真值的那一项成员,若都为假，则返回undefined，不会改变原数组。findIndex方法和find方法的原理一样，区别是findIndex方法返回的是第一个符合条件成员的index。如果没有找到符合条件的成员，那么findIndex的返回值是-1。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">&#123;</span>    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token literal-property property">label</span><span class="token operator">:</span> <span class="token string">"1"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token literal-property property">label</span><span class="token operator">:</span> <span class="token string">"2"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>    <span class="token literal-property property">label</span><span class="token operator">:</span> <span class="token string">"3"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token punctuation">&#123;</span>    <span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>    <span class="token literal-property property">label</span><span class="token operator">:</span> <span class="token string">"4"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> item <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> item<span class="token punctuation">.</span>id <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//&#123;id: 2,label: "2"&#125;</span><span class="token keyword">const</span> index <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> item<span class="token punctuation">.</span>id <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-some和every"><a href="#6-some和every" class="headerlink" title="6. some和every"></a>6. some和every</h3><p> some方法有返回值，如果原数组的每一项成员执行迭代函数的结果，有一项为真值，那么some方法会返回true。反之，如果每一项成员执行迭代函数的返回值都是false，那么some方法的返回值就是false。（或）</p><p> every方法有返回值，如果原数组的每一项成员执行迭代函数的结果，有一项为假值，那么every方法会返回false。反之，如果每一项成员执行迭代函数的返回值都是true，那么every方法的返回值就是true。（且）</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">const</span> res <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> item <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span><span class="token keyword">const</span> res <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> item <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="7-indexOf"><a href="#7-indexOf" class="headerlink" title="7. indexOf"></a>7. indexOf</h3><p> indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果匹配到则返回当前项的索引，否则返回-1（如果未找到）。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//0</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"5"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="8-concat"><a href="#8-concat" class="headerlink" title="8. concat"></a>8. concat</h3><p> 把元素衔接到数组中。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span><span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token string">"world!"</span><span class="token punctuation">;</span><span class="token keyword">var</span> n <span class="token operator">=</span> str1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//"Helloworld!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="9-join"><a href="#9-join" class="headerlink" title="9. join"></a>9. join</h3><p> 将数组的所有元素转化为字符串</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> energy <span class="token operator">=</span> fruits<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1,2,3,4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="10-reverse"><a href="#10-reverse" class="headerlink" title="10. reverse"></a>10. reverse</h3><p> 在原数组中颠倒元素的顺序。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//["4", "3", "2", "1"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="11-slice"><a href="#11-slice" class="headerlink" title="11. slice"></a>11. slice</h3><p>截取数组的一部分。索引从0开始，不包括最后一个参数</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"5"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> citrus <span class="token operator">=</span> fruits<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//["2","3"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="12-splice"><a href="#12-splice" class="headerlink" title="12. splice"></a>12. splice</h3><p>插入、删除或替换数组元素。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//插入 在第一个参数前面插入</span><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"5"</span><span class="token punctuation">,</span> <span class="token string">"6"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//["1", "5", "6", "2", "3", "4"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token comment">//删除   第一个参数是开始删除的位置，第二个参数是删除几个，第三个参数是替换被删除的元素</span><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"5"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["1", "5", "3", "4"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="13-sort"><a href="#13-sort" class="headerlink" title="13. sort"></a>13. sort</h3><p> 在原数组中对数组元素进行排序</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"5"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">,</span> <span class="token string">"8"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>fruits<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//["1", "4", "5", "8"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="14-toString"><a href="#14-toString" class="headerlink" title="14.toString"></a>14.toString</h3><p> 将数组转化为字符串。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> newArr <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1,2,3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 循环 </tag>
            
            <tag> 索引 </tag>
            
            <tag> 取值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的反射有多强大</title>
      <link href="/2022/06/22/Java%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%89%E5%A4%9A%E5%BC%BA%E5%A4%A7/"/>
      <url>/2022/06/22/Java%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%89%E5%A4%9A%E5%BC%BA%E5%A4%A7/</url>
      
        <content type="html"><![CDATA[<p>要看到反射有多强大，我们先提一个面试常问的问题，那就是手撕单例模式了。</p><blockquote><p>饿汉式</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 一来就创建，不管你使不使用，那就造成资源浪费了public class Hungry&#123;    private final static Hungry hungry &#x3D; new Hungry();             private Hungry()&#123;                &#x2F;&#x2F; 单例模式，构造器需私有            &#125;        public static Hungry getInstance()&#123;        return hungry;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>懒汉式</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LazyMan&#123;    private static LazyMan lazyman;            private LazyMan()&#123;                         &#125;        public static LazyMan getInstance()&#123;        if(lazyman &#x3D;&#x3D; null)&#123;            lazyman &#x3D; new LazyMan();        &#125;        return lazyman;    &#125;&#125;&#x2F;&#x2F; 单线程下没问题，多线程下出问题了&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;加锁。双重检测模式的 懒汉式单例，DCL 懒汉式public static LazyMan getInstance()&#123;if(lazyman &#x3D;&#x3D; null)&#123;        synchronized (LazyMan.class)&#123;            if(lazyman &#x3D;&#x3D; null)&#123;lazyman &#x3D; new LazyMan();      &#x2F;&#x2F; 不是原子性操作，还是会出现问题                &#x2F;**                * 1、分配内存空间                * 2、执行构造方法，初始化对象                * 3、让这个对象指向这个空间                所以 lazyman 必须加上 Volatile                 *&#x2F;                &#125;        &#125;    &#125;    return lazyman;&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;在上面修改的基础上加上修改private volatile static LazyMan lazyman;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>静态内部类实现</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Holder&#123;    private Holder()&#123;            &#125;        public static Holder getInstace()&#123;        return InnerClass.HOLDER;    &#125;        public static class InnerClass&#123;        private static final Holder HOLDER &#x3D; new Holder();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>反射可以破坏单例</p></blockquote><p>只要有反射，代码就不安全。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LazyMan&#123;    private volatile static LazyMan lazyman;            private LazyMan()&#123;                         &#125;        public static LazyMan getInstance()&#123;if(lazyman &#x3D;&#x3D; null)&#123;        synchronized (LazyMan.class)&#123;            if(lazyman &#x3D;&#x3D; null)&#123;lazyman &#x3D; new LazyMan();  &#125;        &#125;    &#125;    return lazyman;&#125;        &#x2F;&#x2F; 反射    public static void main(String[] args) throws Exception&#123;        LazyMan instance &#x3D; LazyMan.getInstance();        Constructor&lt;LazyMan&gt; declaredConstructor &#x3D; LazyMan.class.getDeclaredConstructor();        declaredConstructor.setAccessible(true);       &#x2F;&#x2F; 破坏私有权限        LazyMan instance2 &#x3D; declaredConstructor.newInstance();        System.out.println(instance &#x3D;&#x3D; instance2);          &#x2F;&#x2F; false  单例被反射破解    &#125;&#125;java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决办法：三重检测</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">在构造器加锁private LazyMan()&#123;                 synchronized (LazyMan.class)&#123;        if(lazyMan!&#x3D;null)&#123;            throw new RuntimeException(&quot;不要试图使用反射破坏单例模式&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>又有一个问题</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">之前两个对象，一个是通过 LazyMan instance &#x3D; LazyMan.getInstance(); 创建的一个是通过反射创建的，如果我两个都是通过反射创建的LazyMan instance1 &#x3D; declaredConstructor.newInstance();LazyMan instance2 &#x3D; declaredConstructor.newInstance();System.out.println(instance1 &#x3D;&#x3D; instance2);          &#x2F;&#x2F; false  单例又被反射破解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决办法：加个标志位（但是如果被反编译了，会发现有此字段，最好就对字段再加密）<strong>四重校验（三层加锁、一层标志位）</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LazyMan&#123;    private volatile static LazyMan lazyman;    private static boolean flag &#x3D; false;    private LazyMan()&#123;                 synchronized (LazyMan.class)&#123;            if(flag)&#123;                throw new RuntimeException(&quot;不要试图使用反射破坏单例模式&quot;);            &#125;else&#123;                flag &#x3D; true;            &#125;    &#125;&#125;        public static LazyMan getInstance()&#123;if(lazyman &#x3D;&#x3D; null)&#123;        synchronized (LazyMan.class)&#123;            if(lazyman &#x3D;&#x3D; null)&#123;lazyman &#x3D; new LazyMan();  &#125;        &#125;    &#125;    return lazyman;&#125;        &#x2F;&#x2F; 反射    public static void main(String[] args) throws Exception&#123;        &#x2F;&#x2F; LazyMan instance &#x3D; LazyMan.getInstance();        Constructor&lt;LazyMan&gt; declaredConstructor &#x3D; LazyMan.class.getDeclaredConstructor();        declaredConstructor.setAccessible(true);        LazyMan instance1 &#x3D; declaredConstructor.newInstance();LazyMan instance2 &#x3D; declaredConstructor.newInstance();System.out.println(instance1 &#x3D;&#x3D; instance2);          &#x2F;&#x2F; false  单例又被反射破解    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过反射拿到字段，再破坏</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 反射public static void main(String[] args) throws Exception&#123;    Field flag &#x3D; LazyMan.class.getDeclaredField(&quot;flag&quot;);   &#x2F;&#x2F; 拿到字段    flag.setAccessible(true);             &#x2F;&#x2F; 破坏字段私有权限Constructor&lt;LazyMan&gt; declaredConstructor &#x3D; LazyMan.class.getDeclaredConstructor();declaredConstructor.setAccessible(true);LazyMan instance1 &#x3D; declaredConstructor.newInstance();LazyMan instance2 &#x3D; declaredConstructor.newInstance();    flag.set(instance,flase);                       &#x2F;&#x2F; 改标志位值System.out.println(instance1 &#x3D;&#x3D; instance2);          &#x2F;&#x2F; false  单例又又又被反射破解&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>找源码！！！枚举（反射不能破坏枚举，枚举可以实现单例）</p><p>枚举类实现单例模式是 effective java 作者极力推荐的单例实现模式，因为枚举类型是<strong>线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，而且</strong>枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p><p>1、除枚举方式外, 其他方法都会通过反射的方式破坏单例,反射是通过调用构造方法生成新的对象，所以如果我们想要阻止单例破坏，可以在构造方法中进行判断，若已有实例, 则阻止生成新的实例，解决办法如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 枚举本身也是一个类public enum EnumSingle&#123;    INSTANCE;    public EnumSingle getInstance()&#123;        return INSTANCE;    &#125;&#125;class Test&#123;    public static void main(String[] args)&#123;        EnumSingle instance1 &#x3D; EnumSingle.INSTANCE;        EnumSingle instance2 &#x3D; EnumSingle.INSTANCE;        System.out.println(instance1 &#x3D;&#x3D; instance2);          &#x2F;&#x2F; true         &#x2F;&#x2F; 使用反射破坏        Constructor&lt;EnumSingle&gt; declaredConstructor &#x3D; EnumSingle.class.getDeclaredConstructor(null);        declaredConstructor.setAccessible(true);   &#x2F;&#x2F; 破坏私有        EnumSingle instance3 &#x3D; declaredConstructor.newInstance();        System.out.println(instance1&#x3D;&#x3D;instance3);    &#125;&#125;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;trueException in thread &quot;main&quot; java.lang.NoSuchMethodException: com.wuhai.single.EnumSingle.&lt;init&gt;()这个异常不是我们想要的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么反射破坏不了枚举的单例模式？</p><p>进源码（发现是空参构造，其实 IDEA 骗了我们）</p><p><img src="https://xiaowu-blog-images.oss-cn-shenzhen.aliyuncs.com/articles/b92fee42a469ac22cedfe7674c00e9a0.png" alt="image20220221165350304.png"></p><p>那就反编译（反编译出来的源码也是空参，还是骗了我们）</p><p><img src="https://xiaowu-blog-images.oss-cn-shenzhen.aliyuncs.com/articles/0bc2fc17a2183c7aa1a4dddbb06531ec.png" alt="image20220221165617282.png"></p><p>那就用专业工具反编译 ( jad.exe )</p><p><img src="https://xiaowu-blog-images.oss-cn-shenzhen.aliyuncs.com/articles/7ab0972fd13078d0091cde824b989941.png" alt="image20220221170215363.png"></p><p><img src="https://xiaowu-blog-images.oss-cn-shenzhen.aliyuncs.com/articles/4c163d18d33914b2938b642a63fd2f4b.png" alt="image20220221170240883.png"></p><p>发现真正的源码是带参数的</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">docker run -p 3306:3306 --name mysql -v mysqlrollback:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;root -d mysql:5.7那就反射时给参数class Test&#123;    public static void main(String[] args)&#123;        EnumSingle instance1 &#x3D; EnumSingle.INSTANCE;        EnumSingle instance2 &#x3D; EnumSingle.INSTANCE;        System.out.println(instance1 &#x3D;&#x3D; instance2);          &#x2F;&#x2F; true         &#x2F;&#x2F; 使用反射破坏        Constructor&lt;EnumSingle&gt; declaredConstructor &#x3D; EnumSingle.class.getDeclaredConstructor(String.class,int.class);        declaredConstructor.setAccessible(true);   &#x2F;&#x2F; 破坏私有        EnumSingle instance3 &#x3D; declaredConstructor.newInstance();        System.out.println(instance1&#x3D;&#x3D;instance3);    &#125;&#125;此时抛出真正想要的异常Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objectsat java.lang.reflect.Constructor.newInstance(Constructor.java:417)at com.wuhai.single.Test.main(EnumSingle.java:21)不能使用反射破坏枚举单例<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 反射 </tag>
            
            <tag> 饿汉式 </tag>
            
            <tag> 懒汉式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻塞队列BlockingQueue和四组API</title>
      <link href="/2022/05/03/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue%E5%92%8C%E5%9B%9B%E7%BB%84API/"/>
      <url>/2022/05/03/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue%E5%92%8C%E5%9B%9B%E7%BB%84API/</url>
      
        <content type="html"><![CDATA[<h2 id="阻塞队列BlockingQueue和四组API"><a href="#阻塞队列BlockingQueue和四组API" class="headerlink" title="阻塞队列BlockingQueue和四组API"></a>阻塞队列BlockingQueue和四组API</h2><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><h3 id="阻塞、队列的概念"><a href="#阻塞、队列的概念" class="headerlink" title="阻塞、队列的概念"></a>阻塞、队列的概念</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB691a6bd9848edd0b31ab6e747db59bea?method=download&shareKey=423f795f63dea6bd9af402ba10996570" alt="阻塞与等待"></p><h3 id="阻塞队列："><a href="#阻塞队列：" class="headerlink" title="阻塞队列："></a>阻塞队列：</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB5b8f92290ba6e95bdafd77112933a299?method=download&shareKey=b31dc8cedfb32a0286f43b7c280675c3" alt="BlockingQueue实现类"></p><p><strong>BlockingQueue 不是新的东西</strong></p><p><strong>什么情况下我们会使用阻塞队列</strong>：多线程并发处理，线程池！</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB394ca09e66e374088cec4187bf31627e?method=download&shareKey=7173f4098ac303bcac3db818d5339838" alt="主要的实现类"></p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2b179c23f019c7454291139b388c34dc?method=download&shareKey=8809530c06e0d424ad5685587712c54d" alt="Blocking树形解释"></p><h3 id="学会使用队列"><a href="#学会使用队列" class="headerlink" title="学会使用队列"></a>学会使用队列</h3><p>（远远不止）添加、移出</p><h2 id="四组API（以下基于ArrayBlockingQueue讲解）"><a href="#四组API（以下基于ArrayBlockingQueue讲解）" class="headerlink" title="四组API（以下基于ArrayBlockingQueue讲解）"></a>四组API（以下基于ArrayBlockingQueue讲解）</h2><table><thead><tr><th>方式</th><th>抛出异常</th><th>不会抛出异常，有返回值</th><th>阻塞 等待</th><th>超时等待</th></tr></thead><tbody><tr><td>添加</td><td>add</td><td>offer()，空参</td><td>put()</td><td>offer(“a”,2,TimeUnit.SECONDS)</td></tr><tr><td>移出</td><td>remove</td><td>poll()</td><td>take()</td><td>offer(2,TimeUnit.SECONDS)</td></tr><tr><td>检测队首元素</td><td>element</td><td>peek</td><td></td><td></td></tr></tbody></table><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.lin.BlockingQueue;import java.util.concurrent.ArrayBlockingQueue;public class BlockingQueueTest &#123;    public static void main(String[] args) &#123;&#x2F;&#x2F;        Collection&#x2F;&#x2F;        List&#x2F;&#x2F;        Set&#x2F;&#x2F;        BlockingQueue 不是新的东西        test1();    &#125;    &#x2F;**     * 抛出异常     * IllegalStateException: Queue full     * NoSuchElementException：Queue empty     *&#x2F;    public static void test1()&#123;&#x2F;&#x2F;        &lt;&gt;是要写泛型吗？不是，而是队列的大小，例如车位只能放几个车        ()        ArrayBlockingQueue arrayBlockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);&#x2F;&#x2F;        add入队操作        System.out.println(arrayBlockingQueue.add(&quot;a&quot;));        System.out.println(arrayBlockingQueue.add(&quot;b&quot;));        System.out.println(arrayBlockingQueue.add(&quot;c&quot;));&#x2F;** * IllegalStateException: Queue full *&#x2F;&#x2F;&#x2F;        System.out.println(arrayBlockingQueue.add(&quot;d&quot;));        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#x2F;&#x2F;         FIFO        for (int i &#x3D; 0; i &lt; 3; i++) &#123;&#x2F;&#x2F;            remove出队操作            System.out.println(arrayBlockingQueue.remove());        &#125;&#x2F;** * NoSuchElementException *&#x2F;&#x2F;&#x2F;        remove以后队列为空，再取抛异常        System.out.println(arrayBlockingQueue.remove());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="不抛出异常，有返回值"><a href="#不抛出异常，有返回值" class="headerlink" title="不抛出异常，有返回值"></a>不抛出异常，有返回值</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"> &#x2F;**     * 不会抛出异常，有返回值     *&#x2F;    public static void test2()&#123;        ArrayBlockingQueue arrayBlockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);&#x2F;&#x2F;        入队        System.out.println(arrayBlockingQueue.offer(&quot;a&quot;));        System.out.println(arrayBlockingQueue.offer(&quot;b&quot;));        System.out.println(arrayBlockingQueue.offer(&quot;c&quot;));        &#x2F;**         * 返回 false          *&#x2F;        System.out.println(arrayBlockingQueue.offer(&quot;d&quot;));        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#x2F;&#x2F;        出队        for (int i &#x3D; 0; i &lt; 3; i++) &#123;            System.out.println(arrayBlockingQueue.poll());        &#125;        &#x2F;**         * 返回 null         *&#x2F;        System.out.println(arrayBlockingQueue.poll());    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="阻塞，等待"><a href="#阻塞，等待" class="headerlink" title="阻塞，等待"></a>阻塞，等待</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**     * 阻塞，等待（一直阻塞）     *&#x2F;    public static void test3() throws InterruptedException &#123;        ArrayBlockingQueue arrayBlockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);&#x2F;&#x2F;        入队&#x2F;&#x2F;        无返回值，一直阻塞        arrayBlockingQueue.put(&quot;a&quot;);        arrayBlockingQueue.put(&quot;b&quot;);        arrayBlockingQueue.put(&quot;c&quot;);&#x2F;&#x2F;        阻塞（一直）&#x2F;&#x2F;        arrayBlockingQueue.put(&quot;d&quot;);&#x2F;&#x2F;   出队        for (int i &#x3D; 0; i &lt; 3; i++) &#123;            System.out.println(arrayBlockingQueue.take());        &#125;&#x2F;&#x2F;        阻塞（一直）&#x2F;&#x2F;        System.out.println(arrayBlockingQueue.take());    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="超时等待"><a href="#超时等待" class="headerlink" title="超时等待"></a>超时等待</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void test4() throws InterruptedException &#123;        ArrayBlockingQueue arrayBlockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);&#x2F;&#x2F;        入队        System.out.println(arrayBlockingQueue.offer(&quot;a&quot;));        System.out.println(arrayBlockingQueue.offer(&quot;b&quot;));        System.out.println(arrayBlockingQueue.offer(&quot;c&quot;));&#x2F;&#x2F;        如果满了就等2s，如果还是满的就超时退出        System.out.println(arrayBlockingQueue.offer(&quot;d&quot;,2,TimeUnit.SECONDS));        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#x2F;&#x2F;        出队        for (int i &#x3D; 0; i &lt; 3; i++) &#123;            System.out.println(arrayBlockingQueue.poll());        &#125;&#x2F;&#x2F;        如果取不出，就超时退出        System.out.println(arrayBlockingQueue.poll(2,TimeUnit.SECONDS));    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 并发线程 </tag>
            
            <tag> 阻塞队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之01背包算法</title>
      <link href="/2022/04/08/01%E8%83%8C%E5%8C%85%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/08/01%E8%83%8C%E5%8C%85%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述</strong><br>给定N个物品和一个背包，背包的容量为W， 假设背包容量范围在[0，15]，第i个物品对应的体积和价值分别为W[i]和v[i]。各种物品的价值和重量如下：<br>物品编号 1 2 3 4 5<br>重量W 3 4 7 8 9<br>价值V 4 5 10 11 13</p><p><strong>解题思路</strong><br>动态规划原理：是一种将问题实例分解为更小的、相似的子问题，并存储子问题的解而避免计算重复的子问题，以解决最优化问题的算法方法。0&#x2F;1背包问题可以看作是决策一个序列（x1,x2,x3,x4,….xn）,对任一变量xi的决策是决定xi&#x3D;1，还是xi&#x3D;0。在对xi-1决策后，已确定了（x1,x2,x3,x4,….xi-1），在决策xi时，问题处于两种状态之一：<br>背包容量不足以装入物品i，则xi&#x3D;0，背包不增加价值；<br>背包容量可以装入物品i，则xi&#x3D;1，背包价值增加了 vi；<br>这两种情况下背包价值的最大者应该是对xi决策后的背包价值。<br>令v（i，j）表示装载前i种物品，总重量不超过j时背包的最大价值<br>面对当前商品有两种可能性：<br>包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)&#x3D;V(i-1,j)；<br>还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)&#x3D;max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。<br>其中V(i-1,j)表示不装，V(i-1,j-w(i))+v(i) 表示装了第i个商品，背包容量减少w(i)，但价值增加了v(i)；</p><p>由此可以得出递推关系式：<br>j&lt;w(i) V(i,j)&#x3D;V(i-1,j)<br>j&gt;&#x3D;w(i) V(i,j)&#x3D;max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝</p><p>根据递推公式,可以逐步求出当物品数为 i ,背包容量为 j 时的背包最大总价值，<br>但在求解之前，要将边界初始化<br>显然的 v(0,j)&#x3D;0，v(i,0)&#x3D;0</p><p><strong>构造最优解</strong><br>通过上面的方法可以求出背包问题的最优解，但还不知道这个最优解由哪些商品组成，可以通过最优解回溯找出解的组成：</p><p>我们可以声明一个长度为6的数组content[6]来标记物品是否选取，content[1]~content[5]分别对应物品1到物品5，将数组初始化为0，<br>1表示选取该物品，0表示不选取<br>V(i,j)&#x3D;V(i-1,j) 或者 j - w[i] &lt;0 时，说明没有选择第i 个商品，则回到V(i-1,j)；<br>否则即说明装了第i个商品，该商品是最优解组成的一部分，content[i]&#x3D;1，然后回到V(i-1,j-w(i))；<br>一直遍历到i＝0结束为止,我们能找到所有解的组成</p><p>(ps:对我来说,单纯看理论概念很容易烦躁而且很难理解，通过源代码结合概念能够有更清晰的认识）</p><p><strong>源代码</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*本关任务：给定N个物品和一个背包，背包的容量为W， 假设背包容量范围在[0，15]，第i个物品对应的体积和价值分别为W[i]和v[i]。各种物品的价值和重量如下：     物品编号   1   2   3   4   5      重量W    3   4   7   8   9      价值V    4   5   10  11  13求: 如何选择装入背包的物品，使得装入背包的物品的总价值为最大.*&#x2F;#include &lt;stdio.h&gt;int content[6]&#x3D;&#123;0&#125;;              &#x2F;&#x2F;最优解的物品组成int w[6]&#x3D;&#123;0,3,4,7,8,9&#125;;          &#x2F;&#x2F;物品对应的重量int v[6]&#x3D;&#123;0,4,5,10,11,13&#125;;       &#x2F;&#x2F;物品对应的价值int bV&#x3D;15;                       &#x2F;&#x2F;背包的最大容量为15int maxVal[6][16]&#x3D;&#123;0&#125;;          &#x2F;&#x2F;存放当物品数为i,背包容量为j的最大总价值void findContent(int i, int j);  &#x2F;&#x2F;找到最优解的物品组成void findMax();                 &#x2F;&#x2F;寻找当物品数为i,背包容量为j时的最大总价值void print();                    &#x2F;&#x2F;打印最优解物品组成int main( void )&#123;    int i,j;    printf(&quot;当物品数为i,背包容量为j时的能装入背包的最大总价值\n&quot;);    findMax();    for (int i&#x3D;0;i&lt;6;i++)  &#x2F;&#x2F;打印当物品数为i,背包容量为j时的最大总价值    &#123;        for(int j&#x3D;0;j&lt;16;j++)        &#123;            printf(&quot;%2d  &quot;,maxVal[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    printf(&quot;请输入当前的物品数：&quot;);    scanf(&quot;%d&quot;,&amp;i);    printf(&quot;请输入当前背包的最大容量: &quot;);    scanf(&quot;%d&quot;,&amp;j);    findContent(i,j);     printf(&quot;最优解的物品组成为： \n&quot;);    for (int k &#x3D; 1; k &lt; 6; k++)    &#123;        if(content[k])        printf(&quot;价值为 %d ,重量为 %d 的 %d 号物品\n&quot;,v[k],w[k],k);    &#125;    printf(&quot;物品数为%d 背包容量为 %d时的最大总价值为 %d\n&quot;,i,j,maxVal[i][j]);    return  0;&#125;void findMax() &#x2F;&#x2F;寻找当物品数为i,背包容量为j时的最大总价值&#123;    for(int i&#x3D;1;i&lt;6;i++)        for(int j&#x3D;1;j&lt;16;j++) &#123;       if (j &lt; w[i])       &#x2F;&#x2F;如果背包容量小于物品i重量，表示背包存放不下第i种物品,此时的最大总价值为i-1种物品的最大总价值                maxVal[i][j] &#x3D; maxVal[i - 1][j];        else    &#123;        if(maxVal[i-1][j]&gt;(maxVal[i-1][j-w[i]]+v[i]))&#x2F;&#x2F;放下第i种物品时的总价值为第i种物品的价值加上当物品数为i-1背包容量为j-w[i]的最优解            maxVal[i][j]&#x3D;maxVal[i-1][j];             &#x2F;&#x2F; 对比当放下第i种物品时的总价值和物品数位i-1时的总价值，取最大值        else            maxVal[i][j]&#x3D;maxVal[i-1][j-w[i]]+v[i];    &#125; &#125;&#125;void findContent(int i, int j) &#123;                &#x2F;&#x2F;最优解组成    if (i &gt; 0 )        &#123;        if (maxVal[i][j] &#x3D;&#x3D; maxVal[i - 1][j] || j - w[i] &lt;0)        &#123;            content[i] &#x3D; 0;            findContent(i - 1, j);        &#125;        else         &#123;            content[i] &#x3D; 1;            findContent(i - 1, j - w[i]);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200425095631713.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用语法</title>
      <link href="/2022/03/28/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/03/28/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown语法真的是非常简单而且好用</p><p>Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。<br>用于编写说明文档，并且以“README.md”的文件名保存在软件的目录下面。<br>除此之外，由于我们有了RStudio这样的神级编辑器，我们还可以快速将Markdown转化为演讲PPT、Word产品文档、LaTex论文甚至是用非常少量的代码完成最小可用原型。在数据科学领域，Markdown已经广泛使用，极大地推进了动态可重复性研究的历史进程。</p><h2 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，两个#是二级标题，以此类推。支持六级标题，标题字号逐级递减降低</p><p><strong>注：标准语法在#后跟个空格再写文字</strong></p><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none"># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>效果如下</strong></p><p><img src="https://img-blog.csdnimg.cn/20200426182643977.png" alt="img"></p><h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h3><p>加粗<br>要加粗的文字左右分别用两个 * 号包起来<br>斜体<br>要倾斜的文字左右分别用一个 * 号包起来<br>斜体加粗<br>要倾斜和加粗的文字左右分别用三个 * 号包起来<br>删除线<br>要加删除线的文字左右分别用两个~~号包起来</p><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none">**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>效果如下：</strong><br><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br>*<strong>这是斜体加粗的文字*</strong><br><del>这是加删除线的文字</del></p><h3 id="3-分割线"><a href="#3-分割线" class="headerlink" title="3.分割线"></a>3.分割线</h3><p>三个或者三个以上的 - 或者 * 都可以</p><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none">---***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>效果如下</strong></p><hr><hr><h3 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h3><p>在需要引用的文字前加&gt;即可</p><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt;这是需要引用的文字<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这是需要引用的文字</p></blockquote><h3 id="5-图片"><a href="#5-图片" class="headerlink" title="5.图片"></a>5.图片</h3><pre class="line-numbers language-none"><code class="language-none">![图片下方显示名字](图片url ”鼠标放在图片上的显示信息“)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none">![图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200507103002365.png &quot;显示信息&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200507103002365.png" alt="图片描述"></p><p><strong>图片描述</strong></p><p>图片的储存上需要用到图床，我使用的是PicGo+Github搭建的免费图床，<br>参考的是压饭大佬的教程<br><a href="https://topking66.gitee.io/go.html?u=aHR0cHM6Ly95YWZpbmUtYmxvZy5jbi9wb3N0cy9lYjNhLmh0bWw=">https://yafine-blog.cn/posts/eb3a.html</a></p><p>(Tips: 我平时经常也把CSDN当成图床,因为CSDN可以上传本地图片,在CSDN写完复制再上传自己的博客也挺舒服的，比如这篇博客就是这样)</p><h3 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6.超链接"></a>6.超链接</h3><pre class="line-numbers language-none"><code class="language-none">[网址名](网址)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>实例：</strong></p><pre class="line-numbers language-none"><code class="language-none">[百度](https:&#x2F;&#x2F;www.baidu.com&#x2F; )[CSDN](https:&#x2F;&#x2F;www.csdn.net&#x2F;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://topking66.gitee.io/go.html?u=aHR0cHM6Ly93d3cuYmFpZHUuY29tLw==">百度</a><br><a href="https://topking66.gitee.io/go.html?u=aHR0cHM6Ly93d3cuY3Nkbi5uZXQv">CSDN</a></p><h3 id="7-列表"><a href="#7-列表" class="headerlink" title="7.列表"></a>7.列表</h3><p><strong>无序列表</strong></p><p>在内容前面加上 * , + ,或者 - （注意空格）</p><pre class="line-numbers language-none"><code class="language-none">* 无序列表- 无序列表+ 无序列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>无序列表</p></li><li><p>无序列表</p></li><li><p>无序列表</p></li></ul><p><strong>有序列表</strong></p><p>数字加上. (后面还是要空格)</p><pre class="line-numbers language-none"><code class="language-none">1. 有序列表2. 有序列表3.  有序列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li><p>有序列表</p></li><li><p>有序列表</p></li><li><p>有序列表</p></li></ol><h3 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h3><pre class="line-numbers language-none"><code class="language-none">表头|表头|表头:---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行-左边加：表示文字居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none">姓名|动作|事件:-|:-:|-:小明|去|上学小红|玩|泥巴小军|吃|辣条<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">姓名</th><th align="left">动作</th><th align="left">事件</th></tr></thead><tbody><tr><td align="left">小明</td><td align="left">去</td><td align="left">上学</td></tr><tr><td align="left">小红</td><td align="left">玩</td><td align="left">泥巴</td></tr><tr><td align="left">小军</td><td align="left">吃</td><td align="left">辣条</td></tr></tbody></table><h3 id="9-代码插入"><a href="#9-代码插入" class="headerlink" title="9.代码插入"></a>9.代码插入</h3><p>单行代码<br>用两个&#96;把代码内容包起来</p><blockquote><pre class="line-numbers language-none"><code class="language-none">hello world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><pre class="line-numbers language-none"><code class="language-none">hello world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代码块<br>用 两个&#96;&#96;&#96;把代码块包起来</p><blockquote><p>`&#96;&#96;<br>#include&lt;stdio.h&gt;<br>void main()<br>{<br>printf(“hello world!”);<br>return 0;<br>}<br>`&#96;&#96;</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;void main()&#123;       printf(&quot;hello world!&quot;);        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="markdown进阶"><a href="#markdown进阶" class="headerlink" title="markdown进阶"></a>markdown进阶</h2><h3 id="10-插入视频"><a href="#10-插入视频" class="headerlink" title="10.插入视频"></a>10.插入视频</h3><p>src里面填视频原URL<br>width是视频宽度（可以填百分比）<br>height是视频高度（可以填百分比）</p><pre class="line-numbers language-none"><code class="language-none">&lt;iframe     width&#x3D;100%    height&#x3D;600px    src&#x3D;&#39;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?aid&#x3D;455564468&amp;bvid&#x3D;BV1H541147nA&amp;cid&#x3D;187808769&amp;page&#x3D;1&#39;    frameborder&#x3D;&quot;0&quot;     allowfullscreen&gt;&lt;&#x2F;iframe&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><iframe width="100%" height="600px" src="https://player.bilibili.com/player.html?aid=455564468&amp;bvid=BV1H541147nA&amp;cid=187808769&amp;page=1" frameborder="0" allowfullscreen="" style="box-sizing: inherit; outline: none; margin: 0px; padding: 0px; color: rgb(52, 73, 94); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen-Sans, Ubuntu, Cantarell, &quot;Helvetica Neue&quot;, sans-serif; font-size: 15px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><h3 id="11-插入音乐"><a href="#11-插入音乐" class="headerlink" title="11.插入音乐"></a>11.插入音乐</h3><pre class="line-numbers language-none"><code class="language-none">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;330 height&#x3D;86 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;1385240480&amp;auto&#x3D;0&amp;height&#x3D;66&quot;&gt;&lt;&#x2F;iframe&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1385240480&amp;auto=0&amp;height=66" style="box-sizing: inherit; outline: none; margin: 0px; padding: 0px; color: rgb(52, 73, 94); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen-Sans, Ubuntu, Cantarell, &quot;Helvetica Neue&quot;, sans-serif; font-size: 15px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><h3 id="12-文字缩进"><a href="#12-文字缩进" class="headerlink" title="12.文字缩进"></a>12.文字缩进</h3><p>在要缩进的文字前使用 <code> </code> （注意空格）</p><p><strong>示例</strong><br>这是缩进前的文字<br>  这是缩进后的文字</p><h3 id="13-文字的居中"><a href="#13-文字的居中" class="headerlink" title="13.文字的居中"></a>13.文字的居中</h3><p>对于标准的markdown文本，是不支持居中对齐的。但是markdown支持html语言，所以我们采用html语法格式来实现</p><pre class="line-numbers language-none"><code class="language-none">&lt;center&gt;这一行需要居中&lt;&#x2F;center&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一行需要居中</p><h3 id="14-文字的字体和颜色"><a href="#14-文字的字体和颜色" class="headerlink" title="14.文字的字体和颜色"></a>14.文字的字体和颜色</h3><p>同样用html语法来实现</p><p>1.字体更换</p><pre class="line-numbers language-none"><code class="language-none">&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我是黑体字</p><p>2.字体大小控制</p><pre class="line-numbers language-none"><code class="language-none">&lt;font  size&#x3D;7 &gt;我很大&lt;&#x2F;font&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我很大</p><p>3.颜色替换</p><pre class="line-numbers language-none"><code class="language-none">&lt;font color&#x3D;yellow &gt;我是什么颜色？&lt;&#x2F;font&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我是什么颜色？</p><p>4.上面的语句可以嵌套使用</p><pre class="line-numbers language-none"><code class="language-none">&lt;center&gt;&lt;font face&#x3D;&quot;微软雅黑&quot; color&#x3D;blue size&#x3D;8&gt;我是谁&lt;&#x2F;font&gt;&lt;&#x2F;center&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我是谁</p><h3 id="15-图片的大小和位置"><a href="#15-图片的大小和位置" class="headerlink" title="15.图片的大小和位置"></a>15.图片的大小和位置</h3><p>通过 center 居中 ，把center换成 left 和 right 可以实现居左或者居右<br>width 和 height 调控高度和宽度</p><pre class="line-numbers language-none"><code class="language-none">&lt;div  align&#x3D;&quot;center&quot;&gt;    &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200507103002365.png&quot; width &#x3D; 30% height &#x3D; 20% &#x2F;&gt;&lt;&#x2F;div&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200507103002365.png" alt="img"></p><h2 id="Markdown编辑器推荐"><a href="#Markdown编辑器推荐" class="headerlink" title="Markdown编辑器推荐"></a>Markdown编辑器推荐</h2><p>我正在使用的markdown编辑器是Typora</p><p>关于Typora<br>Typora 是一款简单、高效而且非常优雅的 Markdown 编辑器，它提供了一种所见即所得的全新的 Markdown 写作体验</p><p>Typora 把源码编辑和效果预览两者合二为一，在输入 Markdown 代码的时候即时生成预览效果</p><p>Typora 是目前互联网上最受欢迎的 Markdown 编辑器之一</p><p>下载地址：<a href="https://topking66.gitee.io/go.html?u=aHR0cHM6Ly93d3cudHlwb3JhLmlv">传送门</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
