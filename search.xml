<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>阻塞队列BlockingQueue和四组API</title>
      <link href="/2022/05/03/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue%E5%92%8C%E5%9B%9B%E7%BB%84API/"/>
      <url>/2022/05/03/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97BlockingQueue%E5%92%8C%E5%9B%9B%E7%BB%84API/</url>
      
        <content type="html"><![CDATA[<h2 id="阻塞队列BlockingQueue和四组API"><a href="#阻塞队列BlockingQueue和四组API" class="headerlink" title="阻塞队列BlockingQueue和四组API"></a>阻塞队列BlockingQueue和四组API</h2><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><h3 id="阻塞、队列的概念"><a href="#阻塞、队列的概念" class="headerlink" title="阻塞、队列的概念"></a>阻塞、队列的概念</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB691a6bd9848edd0b31ab6e747db59bea?method=download&shareKey=423f795f63dea6bd9af402ba10996570" alt="阻塞与等待"></p><h3 id="阻塞队列："><a href="#阻塞队列：" class="headerlink" title="阻塞队列："></a>阻塞队列：</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB5b8f92290ba6e95bdafd77112933a299?method=download&shareKey=b31dc8cedfb32a0286f43b7c280675c3" alt="BlockingQueue实现类"></p><p><strong>BlockingQueue 不是新的东西</strong></p><p><strong>什么情况下我们会使用阻塞队列</strong>：多线程并发处理，线程池！</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB394ca09e66e374088cec4187bf31627e?method=download&shareKey=7173f4098ac303bcac3db818d5339838" alt="主要的实现类"></p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB2b179c23f019c7454291139b388c34dc?method=download&shareKey=8809530c06e0d424ad5685587712c54d" alt="Blocking树形解释"></p><h3 id="学会使用队列"><a href="#学会使用队列" class="headerlink" title="学会使用队列"></a>学会使用队列</h3><p>（远远不止）添加、移出</p><h2 id="四组API（以下基于ArrayBlockingQueue讲解）"><a href="#四组API（以下基于ArrayBlockingQueue讲解）" class="headerlink" title="四组API（以下基于ArrayBlockingQueue讲解）"></a>四组API（以下基于ArrayBlockingQueue讲解）</h2><table><thead><tr><th>方式</th><th>抛出异常</th><th>不会抛出异常，有返回值</th><th>阻塞 等待</th><th>超时等待</th></tr></thead><tbody><tr><td>添加</td><td>add</td><td>offer()，空参</td><td>put()</td><td>offer(“a”,2,TimeUnit.SECONDS)</td></tr><tr><td>移出</td><td>remove</td><td>poll()</td><td>take()</td><td>offer(2,TimeUnit.SECONDS)</td></tr><tr><td>检测队首元素</td><td>element</td><td>peek</td><td></td><td></td></tr></tbody></table><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.lin.BlockingQueue;import java.util.concurrent.ArrayBlockingQueue;public class BlockingQueueTest &#123;    public static void main(String[] args) &#123;&#x2F;&#x2F;        Collection&#x2F;&#x2F;        List&#x2F;&#x2F;        Set&#x2F;&#x2F;        BlockingQueue 不是新的东西        test1();    &#125;    &#x2F;**     * 抛出异常     * IllegalStateException: Queue full     * NoSuchElementException：Queue empty     *&#x2F;    public static void test1()&#123;&#x2F;&#x2F;        &lt;&gt;是要写泛型吗？不是，而是队列的大小，例如车位只能放几个车        ()        ArrayBlockingQueue arrayBlockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);&#x2F;&#x2F;        add入队操作        System.out.println(arrayBlockingQueue.add(&quot;a&quot;));        System.out.println(arrayBlockingQueue.add(&quot;b&quot;));        System.out.println(arrayBlockingQueue.add(&quot;c&quot;));&#x2F;** * IllegalStateException: Queue full *&#x2F;&#x2F;&#x2F;        System.out.println(arrayBlockingQueue.add(&quot;d&quot;));        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#x2F;&#x2F;         FIFO        for (int i &#x3D; 0; i &lt; 3; i++) &#123;&#x2F;&#x2F;            remove出队操作            System.out.println(arrayBlockingQueue.remove());        &#125;&#x2F;** * NoSuchElementException *&#x2F;&#x2F;&#x2F;        remove以后队列为空，再取抛异常        System.out.println(arrayBlockingQueue.remove());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="不抛出异常，有返回值"><a href="#不抛出异常，有返回值" class="headerlink" title="不抛出异常，有返回值"></a>不抛出异常，有返回值</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"> &#x2F;**     * 不会抛出异常，有返回值     *&#x2F;    public static void test2()&#123;        ArrayBlockingQueue arrayBlockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);&#x2F;&#x2F;        入队        System.out.println(arrayBlockingQueue.offer(&quot;a&quot;));        System.out.println(arrayBlockingQueue.offer(&quot;b&quot;));        System.out.println(arrayBlockingQueue.offer(&quot;c&quot;));        &#x2F;**         * 返回 false          *&#x2F;        System.out.println(arrayBlockingQueue.offer(&quot;d&quot;));        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#x2F;&#x2F;        出队        for (int i &#x3D; 0; i &lt; 3; i++) &#123;            System.out.println(arrayBlockingQueue.poll());        &#125;        &#x2F;**         * 返回 null         *&#x2F;        System.out.println(arrayBlockingQueue.poll());    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="阻塞，等待"><a href="#阻塞，等待" class="headerlink" title="阻塞，等待"></a>阻塞，等待</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**     * 阻塞，等待（一直阻塞）     *&#x2F;    public static void test3() throws InterruptedException &#123;        ArrayBlockingQueue arrayBlockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);&#x2F;&#x2F;        入队&#x2F;&#x2F;        无返回值，一直阻塞        arrayBlockingQueue.put(&quot;a&quot;);        arrayBlockingQueue.put(&quot;b&quot;);        arrayBlockingQueue.put(&quot;c&quot;);&#x2F;&#x2F;        阻塞（一直）&#x2F;&#x2F;        arrayBlockingQueue.put(&quot;d&quot;);&#x2F;&#x2F;   出队        for (int i &#x3D; 0; i &lt; 3; i++) &#123;            System.out.println(arrayBlockingQueue.take());        &#125;&#x2F;&#x2F;        阻塞（一直）&#x2F;&#x2F;        System.out.println(arrayBlockingQueue.take());    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="超时等待"><a href="#超时等待" class="headerlink" title="超时等待"></a>超时等待</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void test4() throws InterruptedException &#123;        ArrayBlockingQueue arrayBlockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;(3);&#x2F;&#x2F;        入队        System.out.println(arrayBlockingQueue.offer(&quot;a&quot;));        System.out.println(arrayBlockingQueue.offer(&quot;b&quot;));        System.out.println(arrayBlockingQueue.offer(&quot;c&quot;));&#x2F;&#x2F;        如果满了就等2s，如果还是满的就超时退出        System.out.println(arrayBlockingQueue.offer(&quot;d&quot;,2,TimeUnit.SECONDS));        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);&#x2F;&#x2F;        出队        for (int i &#x3D; 0; i &lt; 3; i++) &#123;            System.out.println(arrayBlockingQueue.poll());        &#125;&#x2F;&#x2F;        如果取不出，就超时退出        System.out.println(arrayBlockingQueue.poll(2,TimeUnit.SECONDS));    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 并发线程 </tag>
            
            <tag> 阻塞队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基础</title>
      <link href="/2022/04/25/JVM%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/04/25/JVM%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpirngBoot之IDEA中各类标志不可用问题</title>
      <link href="/2022/04/08/SpirngBoot%E4%B9%8BIDEA%E4%B8%AD%E5%90%84%E7%B1%BB%E6%A0%87%E5%BF%97%E4%B8%8D%E5%8F%AF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/08/SpirngBoot%E4%B9%8BIDEA%E4%B8%AD%E5%90%84%E7%B1%BB%E6%A0%87%E5%BF%97%E4%B8%8D%E5%8F%AF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="出现这类问题的情况"><a href="#出现这类问题的情况" class="headerlink" title="出现这类问题的情况"></a>出现这类问题的情况</h2><ul><li><p><strong>在我们打开其他springboot项目之后，可能会出现</strong></p></li><li><p><strong>在我们有一段时间没有启动此项目也有可能会出现</strong></p></li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li><strong>首先，进入问题项目，箭头标志的便是各类标志出现红色小标不可用问题</strong></li></ul><p><img src="https://note.youdao.com/yws/api/personal/file/WEBa223a39478af6a174daf6ae0239d7e28?method=download&shareKey=e5e611aab0390cb2a915aaeace4604a4" alt="] "></p><p>]</p><p><strong>java资源跟和resource资源目录是一样的操作</strong></p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBf5d3b5d89ac114f5503c84c064e64d9b?method=download&shareKey=0b2e5bfa7d1b0f55c6ad15f1ca650dcb" alt="java资源根"></p><p><strong>下面是pom.xml的操作</strong></p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB620f070dcc26e4f63a163195864e16c3?method=download&shareKey=271c760c3ae2d75e5abe44125661e0fc" alt="pom.xml"></p><p><strong>最后展示</strong></p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBdca487ab813dd492aeff8d7e70c8ba87?method=download&shareKey=dea02de61871db73cab75f3d09c46f1f" alt="img"></p><p><strong>这样就解决啦！！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> pom.xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之01背包算法</title>
      <link href="/2022/04/08/01%E8%83%8C%E5%8C%85%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/08/01%E8%83%8C%E5%8C%85%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>问题描述</strong><br>给定N个物品和一个背包，背包的容量为W， 假设背包容量范围在[0，15]，第i个物品对应的体积和价值分别为W[i]和v[i]。各种物品的价值和重量如下：<br>物品编号 1 2 3 4 5<br>重量W 3 4 7 8 9<br>价值V 4 5 10 11 13</p><p><strong>解题思路</strong><br>动态规划原理：是一种将问题实例分解为更小的、相似的子问题，并存储子问题的解而避免计算重复的子问题，以解决最优化问题的算法方法。0&#x2F;1背包问题可以看作是决策一个序列（x1,x2,x3,x4,….xn）,对任一变量xi的决策是决定xi&#x3D;1，还是xi&#x3D;0。在对xi-1决策后，已确定了（x1,x2,x3,x4,….xi-1），在决策xi时，问题处于两种状态之一：<br>背包容量不足以装入物品i，则xi&#x3D;0，背包不增加价值；<br>背包容量可以装入物品i，则xi&#x3D;1，背包价值增加了 vi；<br>这两种情况下背包价值的最大者应该是对xi决策后的背包价值。<br>令v（i，j）表示装载前i种物品，总重量不超过j时背包的最大价值<br>面对当前商品有两种可能性：<br>包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)&#x3D;V(i-1,j)；<br>还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)&#x3D;max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。<br>其中V(i-1,j)表示不装，V(i-1,j-w(i))+v(i) 表示装了第i个商品，背包容量减少w(i)，但价值增加了v(i)；</p><p>由此可以得出递推关系式：<br>j&lt;w(i) V(i,j)&#x3D;V(i-1,j)<br>j&gt;&#x3D;w(i) V(i,j)&#x3D;max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝</p><p>根据递推公式,可以逐步求出当物品数为 i ,背包容量为 j 时的背包最大总价值，<br>但在求解之前，要将边界初始化<br>显然的 v(0,j)&#x3D;0，v(i,0)&#x3D;0</p><p><strong>构造最优解</strong><br>通过上面的方法可以求出背包问题的最优解，但还不知道这个最优解由哪些商品组成，可以通过最优解回溯找出解的组成：</p><p>我们可以声明一个长度为6的数组content[6]来标记物品是否选取，content[1]~content[5]分别对应物品1到物品5，将数组初始化为0，<br>1表示选取该物品，0表示不选取<br>V(i,j)&#x3D;V(i-1,j) 或者 j - w[i] &lt;0 时，说明没有选择第i 个商品，则回到V(i-1,j)；<br>否则即说明装了第i个商品，该商品是最优解组成的一部分，content[i]&#x3D;1，然后回到V(i-1,j-w(i))；<br>一直遍历到i＝0结束为止,我们能找到所有解的组成</p><p>(ps:对我来说,单纯看理论概念很容易烦躁而且很难理解，通过源代码结合概念能够有更清晰的认识）</p><p><strong>源代码</strong>：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">&#x2F;*本关任务：给定N个物品和一个背包，背包的容量为W， 假设背包容量范围在[0，15]，第i个物品对应的体积和价值分别为W[i]和v[i]。各种物品的价值和重量如下：     物品编号   1   2   3   4   5      重量W    3   4   7   8   9      价值V    4   5   10  11  13求: 如何选择装入背包的物品，使得装入背包的物品的总价值为最大.*&#x2F;#include &lt;stdio.h&gt;int content[6]&#x3D;&#123;0&#125;;              &#x2F;&#x2F;最优解的物品组成int w[6]&#x3D;&#123;0,3,4,7,8,9&#125;;          &#x2F;&#x2F;物品对应的重量int v[6]&#x3D;&#123;0,4,5,10,11,13&#125;;       &#x2F;&#x2F;物品对应的价值int bV&#x3D;15;                       &#x2F;&#x2F;背包的最大容量为15int maxVal[6][16]&#x3D;&#123;0&#125;;          &#x2F;&#x2F;存放当物品数为i,背包容量为j的最大总价值void findContent(int i, int j);  &#x2F;&#x2F;找到最优解的物品组成void findMax();                 &#x2F;&#x2F;寻找当物品数为i,背包容量为j时的最大总价值void print();                    &#x2F;&#x2F;打印最优解物品组成int main( void )&#123;    int i,j;    printf(&quot;当物品数为i,背包容量为j时的能装入背包的最大总价值\n&quot;);    findMax();    for (int i&#x3D;0;i&lt;6;i++)  &#x2F;&#x2F;打印当物品数为i,背包容量为j时的最大总价值    &#123;        for(int j&#x3D;0;j&lt;16;j++)        &#123;            printf(&quot;%2d  &quot;,maxVal[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    printf(&quot;请输入当前的物品数：&quot;);    scanf(&quot;%d&quot;,&amp;i);    printf(&quot;请输入当前背包的最大容量: &quot;);    scanf(&quot;%d&quot;,&amp;j);    findContent(i,j);     printf(&quot;最优解的物品组成为： \n&quot;);    for (int k &#x3D; 1; k &lt; 6; k++)    &#123;        if(content[k])        printf(&quot;价值为 %d ,重量为 %d 的 %d 号物品\n&quot;,v[k],w[k],k);    &#125;    printf(&quot;物品数为%d 背包容量为 %d时的最大总价值为 %d\n&quot;,i,j,maxVal[i][j]);    return  0;&#125;void findMax() &#x2F;&#x2F;寻找当物品数为i,背包容量为j时的最大总价值&#123;    for(int i&#x3D;1;i&lt;6;i++)        for(int j&#x3D;1;j&lt;16;j++) &#123;       if (j &lt; w[i])       &#x2F;&#x2F;如果背包容量小于物品i重量，表示背包存放不下第i种物品,此时的最大总价值为i-1种物品的最大总价值                maxVal[i][j] &#x3D; maxVal[i - 1][j];        else    &#123;        if(maxVal[i-1][j]&gt;(maxVal[i-1][j-w[i]]+v[i]))&#x2F;&#x2F;放下第i种物品时的总价值为第i种物品的价值加上当物品数为i-1背包容量为j-w[i]的最优解            maxVal[i][j]&#x3D;maxVal[i-1][j];             &#x2F;&#x2F; 对比当放下第i种物品时的总价值和物品数位i-1时的总价值，取最大值        else            maxVal[i][j]&#x3D;maxVal[i-1][j-w[i]]+v[i];    &#125; &#125;&#125;void findContent(int i, int j) &#123;                &#x2F;&#x2F;最优解组成    if (i &gt; 0 )        &#123;        if (maxVal[i][j] &#x3D;&#x3D; maxVal[i - 1][j] || j - w[i] &lt;0)        &#123;            content[i] &#x3D; 0;            findContent(i - 1, j);        &#125;        else         &#123;            content[i] &#x3D; 1;            findContent(i - 1, j - w[i]);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果</strong></p><p><img src="https://img-blog.csdnimg.cn/20200425095631713.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用语法</title>
      <link href="/2022/03/28/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/03/28/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown语法真的是非常简单而且好用</p><p>Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。<br>用于编写说明文档，并且以“README.md”的文件名保存在软件的目录下面。<br>除此之外，由于我们有了RStudio这样的神级编辑器，我们还可以快速将Markdown转化为演讲PPT、Word产品文档、LaTex论文甚至是用非常少量的代码完成最小可用原型。在数据科学领域，Markdown已经广泛使用，极大地推进了动态可重复性研究的历史进程。</p><h2 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，两个#是二级标题，以此类推。支持六级标题，标题字号逐级递减降低</p><p><strong>注：标准语法在#后跟个空格再写文字</strong></p><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none"># 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>效果如下</strong></p><p><img src="https://img-blog.csdnimg.cn/20200426182643977.png" alt="img"></p><h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h3><p>加粗<br>要加粗的文字左右分别用两个 * 号包起来<br>斜体<br>要倾斜的文字左右分别用一个 * 号包起来<br>斜体加粗<br>要倾斜和加粗的文字左右分别用三个 * 号包起来<br>删除线<br>要加删除线的文字左右分别用两个~~号包起来</p><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none">**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>效果如下：</strong><br><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br>*<strong>这是斜体加粗的文字*</strong><br><del>这是加删除线的文字</del></p><h3 id="3-分割线"><a href="#3-分割线" class="headerlink" title="3.分割线"></a>3.分割线</h3><p>三个或者三个以上的 - 或者 * 都可以</p><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none">---***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>效果如下</strong></p><hr><hr><h3 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h3><p>在需要引用的文字前加&gt;即可</p><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none">&gt;这是需要引用的文字<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>这是需要引用的文字</p></blockquote><h3 id="5-图片"><a href="#5-图片" class="headerlink" title="5.图片"></a>5.图片</h3><pre class="line-numbers language-none"><code class="language-none">![图片下方显示名字](图片url ”鼠标放在图片上的显示信息“)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none">![图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200507103002365.png &quot;显示信息&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200507103002365.png" alt="图片描述"></p><p><strong>图片描述</strong></p><p>图片的储存上需要用到图床，我使用的是PicGo+Github搭建的免费图床，<br>参考的是压饭大佬的教程<br><a href="https://topking66.gitee.io/go.html?u=aHR0cHM6Ly95YWZpbmUtYmxvZy5jbi9wb3N0cy9lYjNhLmh0bWw=">https://yafine-blog.cn/posts/eb3a.html</a></p><p>(Tips: 我平时经常也把CSDN当成图床,因为CSDN可以上传本地图片,在CSDN写完复制再上传自己的博客也挺舒服的，比如这篇博客就是这样)</p><h3 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6.超链接"></a>6.超链接</h3><pre class="line-numbers language-none"><code class="language-none">[网址名](网址)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>实例：</strong></p><pre class="line-numbers language-none"><code class="language-none">[百度](https:&#x2F;&#x2F;www.baidu.com&#x2F; )[CSDN](https:&#x2F;&#x2F;www.csdn.net&#x2F;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://topking66.gitee.io/go.html?u=aHR0cHM6Ly93d3cuYmFpZHUuY29tLw==">百度</a><br><a href="https://topking66.gitee.io/go.html?u=aHR0cHM6Ly93d3cuY3Nkbi5uZXQv">CSDN</a></p><h3 id="7-列表"><a href="#7-列表" class="headerlink" title="7.列表"></a>7.列表</h3><p><strong>无序列表</strong></p><p>在内容前面加上 * , + ,或者 - （注意空格）</p><pre class="line-numbers language-none"><code class="language-none">* 无序列表- 无序列表+ 无序列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>无序列表</p></li><li><p>无序列表</p></li><li><p>无序列表</p></li></ul><p><strong>有序列表</strong></p><p>数字加上. (后面还是要空格)</p><pre class="line-numbers language-none"><code class="language-none">1. 有序列表2. 有序列表3.  有序列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li><p>有序列表</p></li><li><p>有序列表</p></li><li><p>有序列表</p></li></ol><h3 id="8-表格"><a href="#8-表格" class="headerlink" title="8.表格"></a>8.表格</h3><pre class="line-numbers language-none"><code class="language-none">表头|表头|表头:---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行-左边加：表示文字居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例：</strong></p><pre class="line-numbers language-none"><code class="language-none">姓名|动作|事件:-|:-:|-:小明|去|上学小红|玩|泥巴小军|吃|辣条<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">姓名</th><th align="left">动作</th><th align="left">事件</th></tr></thead><tbody><tr><td align="left">小明</td><td align="left">去</td><td align="left">上学</td></tr><tr><td align="left">小红</td><td align="left">玩</td><td align="left">泥巴</td></tr><tr><td align="left">小军</td><td align="left">吃</td><td align="left">辣条</td></tr></tbody></table><h3 id="9-代码插入"><a href="#9-代码插入" class="headerlink" title="9.代码插入"></a>9.代码插入</h3><p>单行代码<br>用两个&#96;把代码内容包起来</p><blockquote><pre class="line-numbers language-none"><code class="language-none">hello world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><pre class="line-numbers language-none"><code class="language-none">hello world<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代码块<br>用 两个&#96;&#96;&#96;把代码块包起来</p><blockquote><p>`&#96;&#96;<br>#include&lt;stdio.h&gt;<br>void main()<br>{<br>printf(“hello world!”);<br>return 0;<br>}<br>`&#96;&#96;</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;void main()&#123;       printf(&quot;hello world!&quot;);        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="markdown进阶"><a href="#markdown进阶" class="headerlink" title="markdown进阶"></a>markdown进阶</h2><h3 id="10-插入视频"><a href="#10-插入视频" class="headerlink" title="10.插入视频"></a>10.插入视频</h3><p>src里面填视频原URL<br>width是视频宽度（可以填百分比）<br>height是视频高度（可以填百分比）</p><pre class="line-numbers language-none"><code class="language-none">&lt;iframe     width&#x3D;100%    height&#x3D;600px    src&#x3D;&#39;&#x2F;&#x2F;player.bilibili.com&#x2F;player.html?aid&#x3D;455564468&amp;bvid&#x3D;BV1H541147nA&amp;cid&#x3D;187808769&amp;page&#x3D;1&#39;    frameborder&#x3D;&quot;0&quot;     allowfullscreen&gt;&lt;&#x2F;iframe&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><iframe width="100%" height="600px" src="https://player.bilibili.com/player.html?aid=455564468&amp;bvid=BV1H541147nA&amp;cid=187808769&amp;page=1" frameborder="0" allowfullscreen="" style="box-sizing: inherit; outline: none; margin: 0px; padding: 0px; color: rgb(52, 73, 94); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen-Sans, Ubuntu, Cantarell, &quot;Helvetica Neue&quot;, sans-serif; font-size: 15px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><h3 id="11-插入音乐"><a href="#11-插入音乐" class="headerlink" title="11.插入音乐"></a>11.插入音乐</h3><pre class="line-numbers language-none"><code class="language-none">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;330 height&#x3D;86 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;1385240480&amp;auto&#x3D;0&amp;height&#x3D;66&quot;&gt;&lt;&#x2F;iframe&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=1385240480&amp;auto=0&amp;height=66" style="box-sizing: inherit; outline: none; margin: 0px; padding: 0px; color: rgb(52, 73, 94); font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Oxygen-Sans, Ubuntu, Cantarell, &quot;Helvetica Neue&quot;, sans-serif; font-size: 15px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"></iframe><h3 id="12-文字缩进"><a href="#12-文字缩进" class="headerlink" title="12.文字缩进"></a>12.文字缩进</h3><p>在要缩进的文字前使用 <code> </code> （注意空格）</p><p><strong>示例</strong><br>这是缩进前的文字<br>  这是缩进后的文字</p><h3 id="13-文字的居中"><a href="#13-文字的居中" class="headerlink" title="13.文字的居中"></a>13.文字的居中</h3><p>对于标准的markdown文本，是不支持居中对齐的。但是markdown支持html语言，所以我们采用html语法格式来实现</p><pre class="line-numbers language-none"><code class="language-none">&lt;center&gt;这一行需要居中&lt;&#x2F;center&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一行需要居中</p><h3 id="14-文字的字体和颜色"><a href="#14-文字的字体和颜色" class="headerlink" title="14.文字的字体和颜色"></a>14.文字的字体和颜色</h3><p>同样用html语法来实现</p><p>1.字体更换</p><pre class="line-numbers language-none"><code class="language-none">&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我是黑体字</p><p>2.字体大小控制</p><pre class="line-numbers language-none"><code class="language-none">&lt;font  size&#x3D;7 &gt;我很大&lt;&#x2F;font&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我很大</p><p>3.颜色替换</p><pre class="line-numbers language-none"><code class="language-none">&lt;font color&#x3D;yellow &gt;我是什么颜色？&lt;&#x2F;font&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我是什么颜色？</p><p>4.上面的语句可以嵌套使用</p><pre class="line-numbers language-none"><code class="language-none">&lt;center&gt;&lt;font face&#x3D;&quot;微软雅黑&quot; color&#x3D;blue size&#x3D;8&gt;我是谁&lt;&#x2F;font&gt;&lt;&#x2F;center&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我是谁</p><h3 id="15-图片的大小和位置"><a href="#15-图片的大小和位置" class="headerlink" title="15.图片的大小和位置"></a>15.图片的大小和位置</h3><p>通过 center 居中 ，把center换成 left 和 right 可以实现居左或者居右<br>width 和 height 调控高度和宽度</p><pre class="line-numbers language-none"><code class="language-none">&lt;div  align&#x3D;&quot;center&quot;&gt;    &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200507103002365.png&quot; width &#x3D; 30% height &#x3D; 20% &#x2F;&gt;&lt;&#x2F;div&gt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200507103002365.png" alt="img"></p><h2 id="Markdown编辑器推荐"><a href="#Markdown编辑器推荐" class="headerlink" title="Markdown编辑器推荐"></a>Markdown编辑器推荐</h2><p>我正在使用的markdown编辑器是Typora</p><p>关于Typora<br>Typora 是一款简单、高效而且非常优雅的 Markdown 编辑器，它提供了一种所见即所得的全新的 Markdown 写作体验</p><p>Typora 把源码编辑和效果预览两者合二为一，在输入 Markdown 代码的时候即时生成预览效果</p><p>Typora 是目前互联网上最受欢迎的 Markdown 编辑器之一</p><p>下载地址：<a href="https://topking66.gitee.io/go.html?u=aHR0cHM6Ly93d3cudHlwb3JhLmlv">传送门</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
